<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinySA Spectrum Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            border-radius: 15px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4a5568;
            font-size: 14px;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ff;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #4a6cf7;
            box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 108, 247, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }

        .chart-container {
            background: #ffffff;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e1e8ff;
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
            width: 100%;
        }

        .marker-info {
            background: linear-gradient(45deg, #ffd89b, #19547b);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .marker-info h3 {
            margin-bottom: 10px;
        }

        .status-bar {
            background: #2d3748;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .unit-label {
            background: #e1e8ff;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            color: #4a5568;
            display: flex;
            align-items: center;
        }

        .status-indicator {
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        .status-indicator.connected {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .status-indicator.disconnected {
            background: linear-gradient(45deg, #f56565, #e53e3e);
            color: white;
        }

        .status-indicator.connecting {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .command-log {
            background: #2d3748;
            color: #68d391;
            font-family: monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            margin-top: 15px;
            border: 2px solid #4a5568;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
        }

        .debug-info {
            background: #f0f4f8;
            border: 2px solid #bee3f8;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 TinySA Spectrum Analyzer</h1>
            <p>RF 신호 분석 도구</p>
        </div>

        <div class="controls-grid">
            <div class="control-panel">
                <h2>🔌 장치 연결</h2>
                
                <div class="control-group">
                    <label>연결 상태</label>
                    <div id="connectionStatus" class="status-indicator disconnected">연결 안됨</div>
                </div>

                <div class="control-group">
                    <label>보드레이트 (bps)</label>
                    <select id="baudRate">
                        <option value="9600" selected>9600 (시스템 기본값)</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200">115200 (tinySA 표준)</option>
                        <option value="230400">230400</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="connectBtn" onclick="connectDevice()">🔌 연결</button>
                    <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnectDevice()" disabled>❌ 연결 해제</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="diagnoseConnection()" id="diagnoseBtn" disabled>🔍 진단</button>
                    <button class="btn btn-secondary" onclick="clearLog()">🗑️ 로그 지우기</button>
                </div>

                <hr style="margin: 20px 0; border: 1px solid #e1e8ff;">

                <h2>📡 주파수 설정</h2>
                
                <div class="control-group">
                    <label>시작 주파수</label>
                    <div class="input-group">
                        <input type="number" id="startFreq" value="1" step="0.1">
                        <span class="unit-label">MHz</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>종료 주파수</label>
                    <div class="input-group">
                        <input type="number" id="stopFreq" value="900" step="0.1">
                        <span class="unit-label">MHz</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>스캔 포인트</label>
                    <select id="scanPoints">
                        <option value="101">101</option>
                        <option value="201">201</option>
                        <option value="301">301</option>
                        <option value="501">501</option>
                        <option value="801">801</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="startScan()">🔍 스캔 시작</button>
                    <button class="btn btn-secondary" onclick="downloadCSV()">💾 CSV 저장</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="testChart()">🧪 차트 테스트</button>
                    <button class="btn btn-secondary" onclick="debugChart()">🔧 차트 디버그</button>
                </div>

                <div class="marker-info">
                    <h3>📍 마커 정보</h3>
                    <div id="markerInfo">차트를 클릭하여 마커를 설정하세요</div>
                </div>

                <div class="control-group">
                    <label>명령 로그</label>
                    <div id="commandLog" class="command-log">시스템 준비됨...\n</div>
                </div>

                <div class="debug-info" id="debugInfo">
                    차트 상태: 준비 중...
                </div>
            </div>

            <div class="chart-container">
                <h2>📊 스펙트럼 분석</h2>
                <div class="chart-wrapper">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusDisplay">시스템 준비됨 - 스캔을 시작하세요</div>
        </div>
    </div>

    <script>
        let chart;
        let spectrumData = [];
        let frequencies = [];
        let isScanning = false;
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;

        // TinySA 장치 식별자
        const TINYSA_VID = 0x0483;
        const TINYSA_PID = 0x5740;

        // Step 1: 디버그 헬퍼 함수들
        function updateDebugInfo(message) {
            const debugElement = document.getElementById('debugInfo');
            if (debugElement) {
                debugElement.textContent = message;
            }
            logCommand(`🔧 DEBUG: ${message}`);
        }

        function debugChart() {
            logCommand('🔍 === 차트 디버그 시작 ===');
            
            updateDebugInfo('차트 디버그 실행 중...');
            
            // 기본 정보
            logCommand(`차트 객체 존재: ${chart ? 'YES' : 'NO'}`);
            logCommand(`Chart.js 라이브러리: ${typeof Chart !== 'undefined' ? 'YES' : 'NO'}`);
            
            // 캔버스 정보
            const canvas = document.getElementById('spectrumChart');
            logCommand(`캔버스 요소 존재: ${canvas ? 'YES' : 'NO'}`);
            
            if (canvas) {
                logCommand(`캔버스 크기: ${canvas.width}x${canvas.height}`);
                logCommand(`캔버스 스타일: ${canvas.style.width}x${canvas.style.height}`);
                
                const ctx = canvas.getContext('2d');
                logCommand(`컨텍스트 존재: ${ctx ? 'YES' : 'NO'}`);
            }
            
            // 차트 상태
            if (chart) {
                logCommand(`차트 타입: ${chart.config.type}`);
                logCommand(`데이터셋 수: ${chart.data.datasets ? chart.data.datasets.length : 0}`);
                logCommand(`라벨 수: ${chart.data.labels ? chart.data.labels.length : 0}`);
                
                if (chart.data.datasets && chart.data.datasets[0]) {
                    logCommand(`데이터 포인트 수: ${chart.data.datasets[0].data ? chart.data.datasets[0].data.length : 0}`);
                }
            }
            
            // 전역 데이터
            logCommand(`전역 주파수 배열: ${frequencies ? frequencies.length + ' 항목' : 'undefined'}`);
            logCommand(`전역 스펙트럼 배열: ${spectrumData ? spectrumData.length + ' 항목' : 'undefined'}`);
            
            updateDebugInfo(`차트 객체: ${chart ? '존재' : '없음'}, 캔버스: ${canvas ? '존재' : '없음'}`);
            
            logCommand('🔍 === 차트 디버그 완료 ===');
        }

        // Step 2: 개선된 차트 초기화
        function initChart() {
            try {
                logCommand('📈 Step 2: 차트 초기화 시작...');
                updateDebugInfo('차트 초기화 중...');
                
                // Chart.js 라이브러리 확인
                if (typeof Chart === 'undefined') {
                    throw new Error('Chart.js 라이브러리가 로드되지 않음');
                }
                
                // 캔버스 요소 확인
                const canvas = document.getElementById('spectrumChart');
                if (!canvas) {
                    throw new Error('스펙트럼 차트 캔버스를 찾을 수 없음');
                }
                
                // 컨텍스트 가져오기
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw new Error('캔버스 컨텍스트를 가져올 수 없음');
                }
                
                // 기존 차트 제거
                if (chart) {
                    logCommand('기존 차트 제거 중...');
                    chart.destroy();
                    chart = null;
                }
                
                // 새 차트 생성
                logCommand('새 차트 인스턴스 생성 중...');
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: '신호 강도 (dBm)',
                            data: [],
                            borderColor: '#4a6cf7',
                            backgroundColor: 'rgba(74, 108, 247, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.1,
                            pointRadius: 1,
                            pointHoverRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: '주파수 (MHz)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: '신호 강도 (dBm)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                min: -100,
                                max: 0
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const elementIndex = elements[0].index;
                                if (frequencies && frequencies[elementIndex] !== undefined && 
                                    spectrumData && spectrumData[elementIndex] !== undefined) {
                                    const frequency = frequencies[elementIndex];
                                    const amplitude = spectrumData[elementIndex];
                                    updateMarker(frequency, amplitude);
                                }
                            }
                        },
                        animation: {
                            duration: 300
                        }
                    }
                });
                
                logCommand('✅ Step 2 완료: 차트 초기화 성공');
                updateDebugInfo('차트 초기화 완료');
                
                return true;
                
            } catch (error) {
                logCommand(`❌ Step 2 실패: 차트 초기화 오류 - ${error.message}`);
                updateDebugInfo(`차트 초기화 실패: ${error.message}`);
                console.error('차트 초기화 오류:', error);
                return false;
            }
        }

        // Step 3: 차트 테스트 함수
        function testChart() {
            try {
                logCommand('🧪 Step 3: 차트 테스트 시작...');
                updateDebugInfo('차트 테스트 실행 중...');
                
                if (!chart) {
                    logCommand('❌ 차트 객체가 없음. 차트 재초기화 시도...');
                    if (!initChart()) {
                        throw new Error('차트 초기화 실패');
                    }
                }
                
                // 테스트 데이터 생성
                const testFreqs = [];
                const testData = [];
                
                for (let i = 0; i <= 20; i++) {
                    const freq = 1 + (i * 44.95); // 1MHz to 900MHz
                    const amp = -90 + Math.random() * 60 + Math.sin(i * 0.5) * 20;
                    testFreqs.push(freq);
                    testData.push(amp);
                }
                
                logCommand(`테스트 데이터 생성: ${testFreqs.length}개 포인트`);
                logCommand(`주파수 범위: ${testFreqs[0].toFixed(1)} - ${testFreqs[testFreqs.length-1].toFixed(1)} MHz`);
                logCommand(`진폭 범위: ${Math.min(...testData).toFixed(1)} - ${Math.max(...testData).toFixed(1)} dBm`);
                
                // 차트 업데이트
                chart.data.labels = testFreqs.map(f => f.toFixed(1));
                chart.data.datasets[0].data = testData;
                
                // 강제 업데이트
                chart.update('none');
                
                // 전역 변수 업데이트
                frequencies = testFreqs;
                spectrumData = testData;
                
                logCommand('✅ Step 3 완료: 차트 테스트 성공');
                updateDebugInfo('차트 테스트 완료 - 데이터 표시됨');
                
                // 상태 업데이트
                document.getElementById('statusDisplay').textContent = 
                    `테스트 데이터 로드됨 - ${testFreqs.length}개 포인트`;
                
            } catch (error) {
                logCommand(`❌ Step 3 실패: 차트 테스트 오류 - ${error.message}`);
                updateDebugInfo(`차트 테스트 실패: ${error.message}`);
                console.error('차트 테스트 오류:', error);
            }
        }

        // Step 4: 대기 함수
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Step 5: 로그 출력 함수
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            if (!logElement) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (message.includes('❌') || message.includes('Error') || message.includes('실패')) {
                console.error('tinySA:', message);
            } else if (message.includes('⚠️') || message.includes('Warning') || message.includes('경고')) {
                console.warn('tinySA:', message);
            } else if (message.includes('✅') || message.includes('Success') || message.includes('성공')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // 연결 상태 업데이트
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            if (!statusElement) return;
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.textContent = '연결됨 ✓';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = false;
                    if (diagnoseBtn) diagnoseBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.textContent = '연결 안됨';
                    if (connectBtn) connectBtn.disabled = false;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.textContent = '연결 중...';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }

        // 안전한 명령 전송
        async function sendCommandSafe(command, timeoutMs = 2000) {
            try {
                logCommand(`📤 명령: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                const response = await readWithQuickTimeout(timeoutMs);
                logCommand(`📥 응답: "${response}"`);
                
                return response;
            } catch (error) {
                logCommand(`⚠️ 명령 "${command}" 오류: ${error.message} (무시됨)`);
                return null;
            }
        }

        // 빠른 타임아웃 읽기
        async function readWithQuickTimeout(timeoutMs) {
            return new Promise(async (resolve) => {
                let response = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(response);
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 500))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.length > 10 || response.includes('>')) {
                            break;
                        }
                    }
                } catch (error) {
                    // 읽기 오류 무시
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                    resolve(response);
                }
            });
        }

        // 연결 정리
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`리더 정리 오류: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`라이터 정리 오류: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`포트 닫기 오류: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`정리 오류: ${error.message}`);
            }
        }

        // 장치 연결
        async function connectDevice() {
            if (!('serial' in navigator)) {
                alert('이 브라우저는 Web Serial API를 지원하지 않습니다. Chrome 기반 브라우저를 사용하세요.');
                return;
            }

            try {
                updateConnectionStatus('connecting', '1단계: 포트 선택 중...');
                
                logCommand('🔍 시리얼 포트 요청 중...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    if (portError.message.includes('No port selected')) {
                        logCommand('⚠️ 사용자가 포트 선택을 취소함');
                        updateConnectionStatus('disconnected', '포트 선택 취소됨');
                        return;
                    } else {
                        logCommand(`❌ 포트 선택 오류: ${portError.message}`);
                        updateConnectionStatus('disconnected', `포트 선택 실패: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`✅ 포트 선택됨: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = parseInt(selectedBaudRate);

                updateConnectionStatus('connecting', `2단계: ${baudRate} bps로 연결 중...`);
                logCommand(`🔧 보드레이트: ${baudRate} bps`);

                await cleanupConnection();
                
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                logCommand(`📡 포트가 성공적으로 열림 (${baudRate} bps)`);

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                logCommand(`   • 리더/라이터 설정 완료`);

                await sleep(300);

                updateConnectionStatus('connecting', `3단계: 통신 테스트 (${baudRate} bps)`);
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    logCommand(`✅ 연결 성공!`);
                    updateConnectionStatus('connected', `tinySA 연결됨 (${baudRate} bps)`);
                    
                    await basicInitialize();
                    return;
                } else {
                    throw new Error('통신 테스트 실패');
                }
                
            } catch (error) {
                updateConnectionStatus('disconnected', `연결 실패: ${error.message}`);
                logCommand(`🚨 최종 연결 실패: ${error.message}`);
                await cleanupConnection();
            }
        }

        // 빠른 연결 테스트
        async function quickConnectionTest() {
            try {
                logCommand('🔄 통신 테스트 시작...');
                
                await sleep(100);
                
                logCommand('   📤 테스트 1: CR 전송');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response1 = await readWithQuickTimeout(1500);
                logCommand(`   📥 응답 1: "${response1}" (길이: ${response1.length})`);
                
                logCommand('   📤 테스트 2: CRLF 전송');
                await writer.write(new TextEncoder().encode('\r\n'));
                
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`   📥 응답 2: "${response2}" (길이: ${response2.length})`);
                
                const combinedResponse = response1 + response2;
                logCommand(`   🔍 결합 분석: "${combinedResponse}"`);
                
                if (combinedResponse.includes('ch>') || 
                    combinedResponse.includes('Ch>') || 
                    combinedResponse.includes('CH>')) {
                    logCommand('   ✅ tinySA 프롬프트 "ch>" 확인됨');
                    return true;
                } else if (combinedResponse.includes('>')) {
                    logCommand('   ✅ 일반 프롬프트 ">" 확인됨 (tinySA일 가능성 높음)');
                    return true;
                } else if (combinedResponse.length > 0) {
                    logCommand('   ⚠️ 응답 수신되었으나 프롬프트 형식이 다름');
                    if (combinedResponse.length > 3) {
                        logCommand('   🔄 응답이 충분함, 연결 시도');
                        return true;
                    }
                    return false;
                } else {
                    logCommand('   ❌ 응답 없음');
                    return false;
                }
                
            } catch (error) {
                logCommand(`❌ 연결 테스트 실패: ${error.message}`);
                return false;
            }
        }

        // 기본 초기화
        async function basicInitialize() {
            try {
                logCommand('🔧 기본 초기화 시작...');
                
                await sleep(200);
                await sendCommandSafe('resume', 1000);
                await sleep(200);
                
                logCommand('✅ 기본 초기화 완료');
                
            } catch (error) {
                logCommand(`⚠️ 초기화 경고: ${error.message} (정상 작동 가능)`);
            }
        }

        // 장치 연결 해제
        async function disconnectDevice() {
            try {
                logCommand('🔌 연결 해제 시작...');
                updateConnectionStatus('connecting', '연결 해제 중...');
                
                await cleanupConnection();
                serialPort = null;
                
                updateConnectionStatus('disconnected', '장치 연결이 성공적으로 해제됨');
                
            } catch (error) {
                logCommand(`연결 해제 오류: ${error.message}`);
                updateConnectionStatus('disconnected', '연결 해제됨 (오류 발생)');
            }
        }

        // 연결 진단
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('❌ 장치가 연결되지 않음');
                alert('먼저 장치를 연결하세요.');
                return;
            }

            try {
                logCommand('🔍 === 연결 진단 시작 ===');
                
                logCommand('1️⃣ 기본 통신 확인...');
                const basicTest = await sendCommandSafe('', 1000);
                logCommand(`   기본 응답: "${basicTest || '응답 없음'}"`);

                logCommand('2️⃣ 프롬프트 확인...');
                const promptTest = await sendCommandSafe('\r', 1000);
                logCommand(`   프롬프트: "${promptTest || '응답 없음'}"`);

                logCommand('3️⃣ 기본 명령 테스트...');
                const resumeTest = await sendCommandSafe('resume', 2000);
                logCommand(`   Resume 응답: "${resumeTest || '응답 없음'}"`);

                logCommand('🔍 === 진단 완료 ===');
                
            } catch (error) {
                logCommand(`❌ 진단 오류: ${error.message}`);
            }
        }

        // 로그 지우기
        function clearLog() {
            const logElement = document.getElementById('commandLog');
            if (logElement) {
                logElement.textContent = '';
                logCommand('📋 로그 지워짐');
            }
        }

        // Step 6: 스캔 시작 (간단한 테스트 데이터로)
        async function startScan() {
            if (isScanning) {
                logCommand('❌ 스캔 시작 불가: 이미 스캔 중');
                return;
            }
            
            isScanning = true;
            document.getElementById('statusDisplay').textContent = '스캔 중...';
            logCommand('🔄 Step 6: 스펙트럼 스캔 시작...');
            updateDebugInfo('스캔 진행 중...');
            
            try {
                // 실제 하드웨어가 연결된 경우
                if (isConnected) {
                    logCommand('🔗 하드웨어에서 데이터 수신 중...');
                    try {
                        const data = await getHardwareSpectrum();
                        
                        if (data && data.frequencies && data.frequencies.length > 0) {
                            logCommand(`✅ 하드웨어 데이터 수신 성공: ${data.frequencies.length} 포인트`);
                            await updateChart(data);
                            logCommand('✅ Step 6 완료: 하드웨어 스캔 성공');
                            return;
                        } else {
                            logCommand('⚠️ 하드웨어 데이터 무효, 테스트 데이터로 전환');
                        }
                    } catch (hwError) {
                        logCommand(`❌ 하드웨어 스캔 실패: ${hwError.message}`);
                    }
                }
                
                // 하드웨어가 없거나 실패한 경우 테스트 데이터 사용
                logCommand('🎯 테스트 데이터 생성 중...');
                const data = generateTestData();
                await updateChart(data);
                
                logCommand('✅ Step 6 완료: 테스트 데이터 스캔 성공');
                
            } catch (error) {
                const errorMsg = `스캔 오류: ${error.message}`;
                document.getElementById('statusDisplay').textContent = errorMsg;
                logCommand(`❌ Step 6 실패: ${errorMsg}`);
                updateDebugInfo(`스캔 실패: ${error.message}`);
                
            } finally {
                isScanning = false;
                logCommand('🏁 스캔 프로세스 종료');
            }
        }

        // Step 7: 테스트 데이터 생성
        function generateTestData() {
            try {
                logCommand('🎯 Step 7: 테스트 데이터 생성...');
                
                const startFreq = parseFloat(document.getElementById('startFreq').value) || 1;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) || 900;
                const points = parseInt(document.getElementById('scanPoints').value) || 101;
                
                logCommand(`   매개변수: ${startFreq}-${stopFreq} MHz, ${points} 포인트`);
                
                const step = (stopFreq - startFreq) / (points - 1);
                const freqs = [];
                const spectrum = [];
                
                for (let i = 0; i < points; i++) {
                    const freq = startFreq + i * step;
                    let amp = -90 + Math.random() * 20; // 기본 노이즈 레벨
                    
                    // 몇 개의 신호 추가
                    if (Math.abs(freq - 100) < 5) {
                        amp = Math.max(amp, -30 - Math.abs(freq - 100) * 4);
                    }
                    if (Math.abs(freq - 433) < 10) {
                        amp = Math.max(amp, -40 - Math.abs(freq - 433) * 2);
                    }
                    if (Math.abs(freq - 868) < 8) {
                        amp = Math.max(amp, -35 - Math.abs(freq - 868) * 3);
                    }
                    
                    freqs.push(freq);
                    spectrum.push(amp);
                }
                
                logCommand(`✅ Step 7 완료: ${freqs.length}개 테스트 데이터 포인트 생성`);
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`❌ Step 7 실패: 테스트 데이터 생성 오류 - ${error.message}`);
                
                // 최소 대체 데이터
                return {
                    frequencies: [1, 100, 200, 500, 900],
                    spectrum: [-90, -40, -60, -50, -80]
                };
            }
        }

        // Step 8: 차트 업데이트
        async function updateChart(data) {
            try {
                logCommand('📈 Step 8: 차트 업데이트 시작...');
                updateDebugInfo('차트 업데이트 중...');
                
                if (!chart) {
                    logCommand('⚠️ 차트 객체가 없음. 재초기화...');
                    if (!initChart()) {
                        throw new Error('차트 초기화 실패');
                    }
                }
                
                if (!data || !data.frequencies || !data.spectrum) {
                    throw new Error('잘못된 데이터 형식');
                }
                
                if (data.frequencies.length !== data.spectrum.length) {
                    throw new Error('주파수와 스펙트럼 데이터 길이가 다름');
                }
                
                logCommand(`   데이터 검증 완료: ${data.frequencies.length} 포인트`);
                logCommand(`   주파수 범위: ${data.frequencies[0].toFixed(2)} - ${data.frequencies[data.frequencies.length-1].toFixed(2)} MHz`);
                logCommand(`   진폭 범위: ${Math.min(...data.spectrum).toFixed(1)} - ${Math.max(...data.spectrum).toFixed(1)} dBm`);
                
                // 전역 변수 업데이트
                frequencies = [...data.frequencies];
                spectrumData = [...data.spectrum];
                
                // 차트 데이터 업데이트
                chart.data.labels = data.frequencies.map(f => f.toFixed(1));
                chart.data.datasets[0].data = [...data.spectrum];
                
                // 차트 업데이트 실행
                chart.update('none');
                
                // 상태 업데이트
                const statusMsg = `스캔 완료 - ${data.frequencies.length}개 포인트, 범위: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                document.getElementById('statusDisplay').textContent = statusMsg;
                
                updateDebugInfo('차트 업데이트 완료');
                logCommand('✅ Step 8 완료: 차트 업데이트 성공');
                
            } catch (error) {
                logCommand(`❌ Step 8 실패: 차트 업데이트 오류 - ${error.message}`);
                updateDebugInfo(`차트 업데이트 실패: ${error.message}`);
                throw error;
            }
        }

        // 하드웨어 스펙트럼 가져오기
        async function getHardwareSpectrum() {
            try {
                const startFreq = parseFloat(document.getElementById('startFreq').value) * 1e6;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) * 1e6;
                const points = parseInt(document.getElementById('scanPoints').value);

                logCommand('📡 === 하드웨어 스펙트럼 측정 시작 ===');
                logCommand(`범위 설정: ${startFreq/1e6} - ${stopFreq/1e6} MHz, ${points} 포인트`);

                await sendCommandSafe('pause');
                await sleep(200);

                await sendCommandSafe(`sweep start ${Math.floor(startFreq)}`);
                await sleep(100);
                await sendCommandSafe(`sweep stop ${Math.floor(stopFreq)}`);
                await sleep(100);

                await sendCommandSafe('resume');
                
                const scanTime = Math.max(1000, points * 5);
                logCommand(`   스캔 완료 대기 중... (${scanTime}ms)`);
                await sleep(scanTime);

                const freqResponse = await sendCommandSafe('frequencies', 5000);
                const dataResponse = await sendCommandSafe('data 0', 5000);
                
                if (!freqResponse || !dataResponse) {
                    throw new Error('스펙트럼 데이터 가져오기 실패');
                }

                // 데이터 파싱
                const freqLines = freqResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const dataLines = dataResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const minLength = Math.min(freqLines.length, dataLines.length);
                const freqs = freqLines.slice(0, minLength).map(freq => freq / 1e6);
                const spectrum = dataLines.slice(0, minLength);

                logCommand('📡 === 하드웨어 스펙트럼 측정 완료 ===');
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`❌ 하드웨어 스캔 오류: ${error.message}`);
                throw error;
            }
        }

        // 마커 업데이트
        function updateMarker(frequency, amplitude) {
            const markerElement = document.getElementById('markerInfo');
            if (markerElement) {
                markerElement.innerHTML = `
                    <strong>주파수:</strong> ${frequency.toFixed(2)} MHz<br>
                    <strong>진폭:</strong> ${amplitude.toFixed(1)} dBm
                `;
            }
        }

        // CSV 다운로드
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('먼저 스캔을 실행하세요.');
                return;
            }

            let csvContent = "주파수(MHz),신호강도(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // 페이지 로드 초기화
        window.addEventListener('load', function() {
            logCommand('🚀 === Step 1: 시스템 초기화 시작 ===');
            
            try {
                updateDebugInfo('시스템 초기화 중...');
                
                // Chart.js 라이브러리 확인
                if (typeof Chart === 'undefined') {
                    logCommand('❌ Chart.js 라이브러리가 로드되지 않음');
                    updateDebugInfo('Chart.js 라이브러리 로드 실패');
                    return;
                }
                
                logCommand('✅ Chart.js 라이브러리 로드 확인');
                
                // 차트 초기화
                if (initChart()) {
                    logCommand('✅ Step 1 완료: 차트 초기화 성공');
                } else {
                    logCommand('❌ Step 1 실패: 차트 초기화 실패');
                    updateDebugInfo('차트 초기화 실패');
                    return;
                }
                
                // Web Serial API 확인
                if (!('serial' in navigator)) {
                    logCommand('❌ 경고: 이 브라우저는 Web Serial API를 지원하지 않습니다.');
                    logCommand('🔧 해결방법: Chrome, Edge, Opera 브라우저를 사용하세요.');
                    updateDebugInfo('Web Serial API 지원 안됨');
                } else {
                    logCommand('✅ Web Serial API 지원됨');
                    
                    // 연결 해제 이벤트 리스너
                    navigator.serial.addEventListener('disconnect', (event) => {
                        if (event.target === serialPort) {
                            updateConnectionStatus('disconnected', '🔌 장치 연결 해제됨 (USB 케이블 확인)');
                            serialPort = null;
                            reader = null;
                            writer = null;
                        }
                    });
                }
                
                // 초기 테스트 차트 표시
                setTimeout(() => {
                    logCommand('🔄 초기 테스트 차트 표시...');
                    testChart();
                }, 500);
                
                logCommand('✅ 전체 시스템 초기화 완료');
                updateDebugInfo('시스템 초기화 완료');
                
            } catch (error) {
                logCommand(`❌ 초기화 오류: ${error.message}`);
                updateDebugInfo(`초기화 실패: ${error.message}`);
                console.error('초기화 오류:', error);
            }
        });
    </script>
</body>
</html>
