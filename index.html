<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinySA Spectrum Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --accent: #06b6d4;
            --accent-dark: #0891b2;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-light: #ffffff;
            --bg-dark: #0f172a;
            --surface-light: #f8fafc;
            --surface-dark: #1e293b;
            --card-light: #ffffff;
            --card-dark: #334155;
            --text-primary-light: #0f172a;
            --text-primary-dark: #f1f5f9;
            --text-secondary-light: #64748b;
            --text-secondary-dark: #94a3b8;
            --border-light: #e2e8f0;
            --border-dark: #475569;
            --shadow-light: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-medium: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-large: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius: 12px;
            --radius-lg: 16px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="light"] {
            --bg: var(--bg-light);
            --surface: var(--surface-light);
            --card: var(--card-light);
            --text-primary: var(--text-primary-light);
            --text-secondary: var(--text-secondary-light);
            --border: var(--border-light);
            --shadow: var(--shadow-light);
        }

        [data-theme="dark"] {
            --bg: var(--bg-dark);
            --surface: var(--surface-dark);
            --card: var(--card-dark);
            --text-primary: var(--text-primary-dark);
            --text-secondary: var(--text-secondary-dark);
            --border: var(--border-dark);
            --shadow: var(--shadow-medium);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            line-height: 1.6;
            transition: var(--transition);
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                45deg,
                rgba(37, 99, 235, 0.03) 0%,
                rgba(6, 182, 212, 0.03) 50%,
                rgba(16, 185, 129, 0.03) 100%
            );
            z-index: -1;
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { transform: translateX(0%) rotate(0deg); }
            50% { transform: translateX(5%) rotate(1deg); }
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            transition: var(--transition);
        }

        [data-theme="dark"] .header {
            background: rgba(15, 23, 42, 0.9);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .page-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-toggle {
            background: none;
            border: 2px solid var(--border);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-secondary);
        }

        .theme-toggle:hover {
            border-color: var(--primary);
            color: var(--primary);
            transform: scale(1.1);
        }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        .hero {
            text-align: center;
            margin-bottom: 3rem;
        }

        .hero h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }

        .hero p {
            font-size: 1.125rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto 1rem;
        }

        /* Card System */
        .card {
            background: var(--card);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 2rem;
            margin-bottom: 2rem;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transform: scaleX(0);
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-large);
        }

        .card:hover::before {
            transform: scaleX(1);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border-radius: var(--radius);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.9rem;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .grid-2 {
            grid-template-columns: 1fr 2fr;
        }

        /* Form Controls */
        .input-group {
            margin-bottom: 1.5rem;
        }

        .input-label {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg);
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .input-group-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.75rem;
            align-items: end;
        }

        .input-unit {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
            display: flex;
            align-items: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--success), var(--accent));
        }

        .btn-full {
            width: 100%;
            justify-content: center;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        /* Status Indicator */
        .status-indicator {
            padding: 0.75rem 1rem;
            border-radius: var(--radius);
            font-weight: 600;
            text-align: center;
            margin-bottom: 1rem;
            transition: var(--transition);
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            border: 2px solid rgba(16, 185, 129, 0.2);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
            border: 2px solid rgba(239, 68, 68, 0.2);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
            border: 2px solid rgba(245, 158, 11, 0.2);
            animation: pulse 2s infinite;
        }

        .status-indicator.scanning {
            background: rgba(6, 182, 212, 0.1);
            color: var(--accent);
            border: 2px solid rgba(6, 182, 212, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Progress Bar */
        .progress-container {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1rem;
            margin: 1rem 0;
            display: none;
        }

        .progress-container.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Chart Container */
        .chart-container {
            background: var(--card);
            border-radius: var(--radius-lg);
            padding: 2rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
            width: 100%;
            margin-top: 1rem;
        }

        /* Marker Info */
        .marker-info {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(6, 182, 212, 0.1));
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-top: 1.5rem;
        }

        .marker-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .marker-content {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Command Log */
        .command-log {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--success);
            margin-top: 1rem;
        }

        .command-log::-webkit-scrollbar {
            width: 6px;
        }

        .command-log::-webkit-scrollbar-track {
            background: var(--surface);
        }

        .command-log::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        /* Debug Info */
        .debug-info {
            background: rgba(6, 182, 212, 0.1);
            border-left: 4px solid var(--accent);
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0 var(--radius) var(--radius) 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent);
        }

        /* Status Bar */
        .status-bar {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1rem;
            margin-top: 2rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeInUp 0.6s ease-out;
        }

        /* Loading State */
        .calculating {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .calculating::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            border-top-color: transparent;
            transform: translate(-50%, -50%);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 968px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }

            .btn-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .card {
                padding: 1.5rem;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .input-group-row {
                grid-template-columns: 1fr;
            }

            .input-unit {
                justify-content: center;
            }
        }

        /* Error Display */
        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card);
            border: 2px solid var(--error);
            border-radius: var(--radius);
            padding: 1rem;
            z-index: 1000;
            animation: fadeInUp 0.3s ease-out;
            box-shadow: var(--shadow-large);
            max-width: 300px;
            color: var(--error);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1 class="page-title">
                <i class="fas fa-chart-line"></i>
                TinySA Spectrum Analyzer
            </h1>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
                <i class="fas fa-moon" id="theme-icon"></i>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <!-- Hero Section -->
        <div class="hero animate-in">
            <h1>RF Signal Analysis Tool</h1>
            <p>Connect with TinySA for real-time spectrum analysis</p>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-2">
            <!-- Control Panel -->
            <div class="card animate-in">
                <h2 class="card-title">
                    <div class="card-icon">
                        <i class="fas fa-cogs"></i>
                    </div>
                    Device Control
                </h2>

                <!-- Connection Status -->
                <div class="input-group">
                    <label class="input-label">Connection Status</label>
                    <div id="connectionStatus" class="status-indicator disconnected">
                        <i class="fas fa-circle"></i> Disconnected
                    </div>
                </div>

                <!-- Baud Rate -->
                <div class="input-group">
                    <label class="input-label">Baud Rate</label>
                    <select id="baudRate" class="input-field">
                        <option value="9600" selected>9600 bps (System Default)</option>
                        <option value="19200">19200 bps</option>
                        <option value="38400">38400 bps</option>
                        <option value="57600">57600 bps</option>
                        <option value="115200">115200 bps (tinySA Standard)</option>
                        <option value="230400">230400 bps</option>
                    </select>
                </div>

                <!-- Connection Buttons -->
                <div class="btn-grid">
                    <button class="btn btn-full" id="connectBtn" onclick="connectDevice()">
                        <i class="fas fa-plug"></i> Connect
                    </button>
                    <button class="btn btn-secondary btn-full" id="disconnectBtn" onclick="disconnectDevice()" disabled>
                        <i class="fas fa-times"></i> Disconnect
                    </button>
                </div>

                <div class="btn-grid">
                    <button class="btn btn-secondary btn-full" onclick="diagnoseConnection()" id="diagnoseBtn" disabled>
                        <i class="fas fa-stethoscope"></i> Diagnose
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="clearLog()">
                        <i class="fas fa-trash"></i> Clear Log
                    </button>
                </div>

                <hr style="margin: 2rem 0; border: none; height: 1px; background: var(--border);">

                <!-- Frequency Settings -->
                <h3 class="card-title" style="font-size: 1.25rem; margin-bottom: 1rem;">
                    <div class="card-icon" style="width: 24px; height: 24px; font-size: 0.8rem;">
                        <i class="fas fa-wave-square"></i>
                    </div>
                    Frequency Settings
                </h3>

                <div class="input-group">
                    <label class="input-label">Start Frequency</label>
                    <div class="input-group-row">
                        <input type="number" id="startFreq" class="input-field" value="0.5" step="0.01">
                        <div class="input-unit">GHz</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">Stop Frequency</label>
                    <div class="input-group-row">
                        <input type="number" id="stopFreq" class="input-field" value="3.0" step="0.01">
                        <div class="input-unit">GHz</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">Scan Points</label>
                    <select id="scanPoints" class="input-field">
                        <option value="25">25 Points</option>
                        <option value="50">50 Points</option>
                        <option value="100" selected>100 Points</option>
                        <option value="200">200 Points</option>
                        <option value="290">290 Points</option>
                        <option value="450">450 Points</option>
                    </select>
                </div>

                <!-- Progress Bar -->
                <div id="progressContainer" class="progress-container">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText" class="progress-text">Initializing scan...</div>
                </div>

                <!-- Scan Buttons -->
                <div class="btn-grid">
                    <button class="btn btn-full" onclick="startScan()" id="scanBtn">
                        <i class="fas fa-search"></i> Start Scan
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="downloadCSV()">
                        <i class="fas fa-download"></i> Save CSV
                    </button>
                </div>

                <div class="btn-grid">
                    <button class="btn btn-secondary btn-full" onclick="testChart()">
                        <i class="fas fa-vial"></i> Test Chart
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="debugChart()">
                        <i class="fas fa-bug"></i> Debug Chart
                    </button>
                </div>

                <!-- Marker Info -->
                <div class="marker-info">
                    <h3 class="marker-title">
                        <i class="fas fa-crosshairs"></i>
                        Marker Information
                    </h3>
                    <div id="markerInfo" class="marker-content">
                        Click on the chart to set marker
                    </div>
                </div>

                <!-- Command Log -->
                <div class="input-group">
                    <label class="input-label">Command Log</label>
                    <div id="commandLog" class="command-log">System ready...\n</div>
                </div>

                <!-- Debug Info -->
                <div class="debug-info" id="debugInfo">
                    Chart status: Ready...
                </div>
            </div>

            <!-- Chart Panel -->
            <div class="chart-container animate-in">
                <h2 class="card-title">
                    <div class="card-icon">
                        <i class="fas fa-chart-area"></i>
                    </div>
                    Spectrum Analysis
                </h2>
                <div class="chart-wrapper">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="statusDisplay">System ready - Start scanning</div>
        </div>
    </div>

    <script>
        let chart;
        let spectrumData = [];
        let frequencies = [];
        let isScanning = false;
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;
        let scanAborted = false;
        let chartInitialized = false;

        // TinySA Device Identifiers
        const TINYSA_VID = 0x0483;
        const TINYSA_PID = 0x5740;

        // Theme Toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            html.setAttribute('data-theme', newTheme);
            
            const icon = document.getElementById('theme-icon');
            icon.className = newTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
            
            localStorage.setItem('theme', newTheme);
        }

        // Initialize theme from localStorage
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            const icon = document.getElementById('theme-icon');
            icon.className = savedTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
        }

        // Progress management
        function showProgress() {
            document.getElementById('progressContainer').classList.add('show');
        }

        function hideProgress() {
            document.getElementById('progressContainer').classList.remove('show');
        }

        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = `${percentage}%`;
            document.getElementById('progressText').textContent = text;
        }

        // Debug helper functions
        function updateDebugInfo(message) {
            const debugElement = document.getElementById('debugInfo');
            if (debugElement) {
                debugElement.textContent = message;
            }
            logCommand(`üîß DEBUG: ${message}`);
        }

        function debugChart() {
            logCommand('üîç === Chart Debug Start ===');
            
            updateDebugInfo('Running chart debug...');
            
            // Basic information
            logCommand(`Chart object exists: ${chart ? 'YES' : 'NO'}`);
            logCommand(`Chart.js library: ${typeof Chart !== 'undefined' ? 'YES' : 'NO'}`);
            logCommand(`Chart initialized: ${chartInitialized ? 'YES' : 'NO'}`);
            
            // Canvas information
            const canvas = document.getElementById('spectrumChart');
            logCommand(`Canvas element exists: ${canvas ? 'YES' : 'NO'}`);
            
            if (canvas) {
                logCommand(`Canvas size: ${canvas.width}x${canvas.height}`);
                logCommand(`Canvas parent size: ${canvas.parentElement.clientWidth}x${canvas.parentElement.clientHeight}`);
                
                const ctx = canvas.getContext('2d');
                logCommand(`Context exists: ${ctx ? 'YES' : 'NO'}`);
            }
            
            // Chart status
            if (chart) {
                logCommand(`Chart type: ${chart.config.type}`);
                logCommand(`Dataset count: ${chart.data.datasets ? chart.data.datasets.length : 0}`);
                logCommand(`Label count: ${chart.data.labels ? chart.data.labels.length : 0}`);
                
                if (chart.data.datasets && chart.data.datasets[0]) {
                    logCommand(`Data point count: ${chart.data.datasets[0].data ? chart.data.datasets[0].data.length : 0}`);
                }
            }
            
            // Global data
            logCommand(`Global frequency array: ${frequencies ? frequencies.length + ' items' : 'undefined'}`);
            logCommand(`Global spectrum array: ${spectrumData ? spectrumData.length + ' items' : 'undefined'}`);
            
            updateDebugInfo(`Chart: ${chart ? 'OK' : 'ERROR'}, Canvas: ${canvas ? 'OK' : 'ERROR'}, Data: ${frequencies.length} points`);
            
            logCommand('üîç === Chart Debug Complete ===');
        }

        // Í∞úÏÑ†Îêú Ï∞®Ìä∏ ÏôÑÏ†Ñ Î¶¨ÏÖã Ìï®Ïàò
        function resetChartCompletely() {
            try {
                logCommand('üîÑ Complete chart reset starting...');
                
                // Í∏ÄÎ°úÎ≤å Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ Ï¥àÍ∏∞Ìôî
                frequencies = [];
                spectrumData = [];
                
                // Ï∞®Ìä∏Í∞Ä Ï°¥Ïû¨ÌïòÎ©¥ ÏôÑÏ†ÑÌûà ÌååÍ¥¥
                if (chart) {
                    logCommand('   Destroying existing chart completely...');
                    chart.destroy();
                    chart = null;
                    chartInitialized = false;
                }
                
                // Ï∫îÎ≤ÑÏä§ Ïª®ÌÖçÏä§Ìä∏ Í∞ïÏ†ú ÌÅ¥Î¶¨Ïñ¥
                const canvas = document.getElementById('spectrumChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    logCommand('   Canvas cleared');
                }
                
                // ÎßàÏª§ Ï†ïÎ≥¥ Î¶¨ÏÖã
                const markerElement = document.getElementById('markerInfo');
                if (markerElement) {
                    markerElement.textContent = 'Click on the chart to set marker';
                }
                
                logCommand('‚úÖ Complete chart reset finished');
                return true;
                
            } catch (error) {
                logCommand(`‚ùå Chart reset error: ${error.message}`);
                return false;
            }
        }

        // Í∞úÏÑ†Îêú Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî
        function initChart() {
            return new Promise((resolve, reject) => {
                try {
                    logCommand('üìà Chart initialization starting...');
                    updateDebugInfo('Initializing chart...');
                    
                    // Chart.js ÎùºÏù¥Î∏åÎü¨Î¶¨ ÌôïÏù∏
                    if (typeof Chart === 'undefined') {
                        throw new Error('Chart.js library not loaded');
                    }
                    
                    // Ï∫îÎ≤ÑÏä§ ÏöîÏÜå ÌôïÏù∏
                    const canvas = document.getElementById('spectrumChart');
                    if (!canvas) {
                        throw new Error('Spectrum chart canvas not found');
                    }
                    
                    // Î∂ÄÎ™® Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞ ÌôïÏù∏
                    const container = canvas.parentElement;
                    if (container.clientWidth === 0 || container.clientHeight === 0) {
                        logCommand('‚ö†Ô∏è Container size is 0. Retrying in 100ms...');
                        setTimeout(() => {
                            initChart().then(resolve).catch(reject);
                        }, 100);
                        return;
                    }
                    
                    // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        throw new Error('Cannot get canvas context');
                    }
                    
                    // Í∏∞Ï°¥ Ï∞®Ìä∏ ÏôÑÏ†Ñ ÌååÍ¥¥
                    if (chart) {
                        logCommand('   Destroying existing chart...');
                        chart.destroy();
                        chart = null;
                    }
                    
                    // ÏÉà Ï∞®Ìä∏ ÏÉùÏÑ±
                    logCommand('   Creating new chart instance...');
                    chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Signal Strength (dBm)',
                                data: [],
                                borderColor: '#2563eb',
                                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.1,
                                pointRadius: 0,
                                pointHoverRadius: 6,
                                pointBackgroundColor: '#2563eb',
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        font: {
                                            family: 'Inter',
                                            weight: '500',
                                            size: 14
                                        },
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                },
                                tooltip: {
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    cornerRadius: 8,
                                    displayColors: false,
                                    callbacks: {
                                        title: function(context) {
                                            return `Frequency: ${context[0].label} MHz`;
                                        },
                                        label: function(context) {
                                            return `Signal Strength: ${context.parsed.y.toFixed(1)} dBm`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Frequency (MHz)',
                                        font: {
                                            family: 'Inter',
                                            size: 14,
                                            weight: '600'
                                        },
                                        color: '#374151'
                                    },
                                    grid: {
                                        color: 'rgba(0, 0, 0, 0.1)',
                                        lineWidth: 1
                                    },
                                    ticks: {
                                        font: {
                                            family: 'Inter',
                                            size: 12
                                        },
                                        color: '#6b7280',
                                        maxTicksLimit: 10
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Signal Strength (dBm)',
                                        font: {
                                            family: 'Inter',
                                            size: 14,
                                            weight: '600'
                                        },
                                        color: '#374151'
                                    },
                                    grid: {
                                        color: 'rgba(0, 0, 0, 0.1)',
                                        lineWidth: 1
                                    },
                                    ticks: {
                                        font: {
                                            family: 'Inter',
                                            size: 12
                                        },
                                        color: '#6b7280'
                                    },
                                    min: -100,
                                    max: 10
                                }
                            },
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const elementIndex = elements[0].index;
                                    if (frequencies && frequencies[elementIndex] !== undefined && 
                                        spectrumData && spectrumData[elementIndex] !== undefined) {
                                        const frequency = frequencies[elementIndex];
                                        const amplitude = spectrumData[elementIndex];
                                        updateMarker(frequency, amplitude);
                                    }
                                }
                            },
                            animation: {
                                duration: 750,
                                easing: 'easeInOutQuart'
                            }
                        }
                    });
                    
                    chartInitialized = true;
                    logCommand('‚úÖ Chart initialization successful');
                    updateDebugInfo('Chart initialization complete');
                    
                    resolve(true);
                    
                } catch (error) {
                    chartInitialized = false;
                    logCommand(`‚ùå Chart initialization failed: ${error.message}`);
                    updateDebugInfo(`Chart initialization failed: ${error.message}`);
                    console.error('Chart initialization error:', error);
                    reject(error);
                }
            });
        }

        // Í∞úÏÑ†Îêú Ï∞®Ìä∏ ÌÖåÏä§Ìä∏ Ìï®Ïàò
        async function testChart() {
            try {
                logCommand('üß™ Chart test starting...');
                updateDebugInfo('Running chart test...');
                
                // Ï∞®Ìä∏ ÏôÑÏ†Ñ Î¶¨ÏÖã ÌõÑ Ïû¨Ï¥àÍ∏∞Ìôî
                resetChartCompletely();
                await sleep(100);
                await initChart();
                
                // ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                const testFreqs = [];
                const testData = [];
                
                // Îçî ÌòÑÏã§Ï†ÅÏù∏ Ïä§ÌéôÌä∏Îüº Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                for (let i = 0; i <= 50; i++) {
                    const freq = 1 + (i * 17.98); // 1MHz to 900MHz, 50 points
                    let amp = -90 + Math.random() * 15; // Í∏∞Î≥∏ ÎÖ∏Ïù¥Ï¶à ÌîåÎ°úÏñ¥
                    
                    // Îã§Ï§ë Ïã†Ìò∏ Ï∂îÍ∞Ä
                    if (Math.abs(freq - 100) < 5) {
                        amp = Math.max(amp, -25 - Math.abs(freq - 100) * 3);
                    }
                    if (Math.abs(freq - 433) < 10) {
                        amp = Math.max(amp, -35 - Math.abs(freq - 433) * 2);
                    }
                    if (Math.abs(freq - 868) < 8) {
                        amp = Math.max(amp, -30 - Math.abs(freq - 868) * 4);
                    }
                    if (Math.abs(freq - 50) < 3) {
                        amp = Math.max(amp, -40 - Math.abs(freq - 50) * 5);
                    }
                    
                    testFreqs.push(freq);
                    testData.push(amp);
                }
                
                logCommand(`Test data generated: ${testFreqs.length} points`);
                logCommand(`Frequency range: ${testFreqs[0].toFixed(1)} - ${testFreqs[testFreqs.length-1].toFixed(1)} MHz`);
                logCommand(`Amplitude range: ${Math.min(...testData).toFixed(1)} - ${Math.max(...testData).toFixed(1)} dBm`);
                
                // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Îçî ÏïàÏ†ÑÌïú Î∞©Î≤ï)
                chart.data.labels = testFreqs.map(f => f.toFixed(1));
                chart.data.datasets[0].data = [...testData];
                
                // Í∞ïÏ†ú ÏóÖÎç∞Ïù¥Ìä∏
                chart.update('active');
                
                // Í∏ÄÎ°úÎ≤å Î≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏
                frequencies = [...testFreqs];
                spectrumData = [...testData];
                
                logCommand('‚úÖ Chart test successful');
                updateDebugInfo('Chart test complete - Actual data displayed');
                
                // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('statusDisplay').textContent = 
                    `Test data loaded - ${testFreqs.length} points (${testFreqs[0].toFixed(1)}-${testFreqs[testFreqs.length-1].toFixed(1)} MHz)`;
                
                // Ï∞®Ìä∏ Î†åÎçîÎßÅ ÌôïÏù∏
                setTimeout(() => {
                    const canvas = document.getElementById('spectrumChart');
                    if (canvas) {
                        logCommand(`Chart rendering confirmed: Canvas size ${canvas.width}x${canvas.height}`);
                    }
                }, 100);
                
            } catch (error) {
                logCommand(`‚ùå Chart test failed: ${error.message}`);
                updateDebugInfo(`Chart test failed: ${error.message}`);
                console.error('Chart test error:', error);
            }
        }

        // Wait function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Log output function
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            if (!logElement) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (message.includes('‚ùå') || message.includes('Error') || message.includes('Failed')) {
                console.error('tinySA:', message);
            } else if (message.includes('‚ö†Ô∏è') || message.includes('Warning') || message.includes('Warning')) {
                console.warn('tinySA:', message);
            } else if (message.includes('‚úÖ') || message.includes('Success') || message.includes('Complete')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // Update connection status
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            if (!statusElement) return;
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> Connected ‚úì';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = false;
                    if (diagnoseBtn) diagnoseBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> Disconnected';
                    if (connectBtn) connectBtn.disabled = false;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> Connecting...';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    break;
                case 'scanning':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> Scanning...';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }

        // Í∞úÏÑ†Îêú Î™ÖÎ†π Ï†ÑÏÜ° Î∞è Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú Ï∞∏Í≥†)
        async function sendCommandAndFetchData(command, timeoutMs = 10000) {
            try {
                logCommand(`üì§ Command: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                const response = await fetchDataUntilPrompt(timeoutMs);
                logCommand(`üì• Response: "${response}" (${response.length} chars)`);
                
                return response;
            } catch (error) {
                logCommand(`‚ö†Ô∏è Command "${command}" error: ${error.message}`);
                return null;
            }
        }

        // Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏùò fetch_data() Ìï®ÏàòÎ•º Ï∞∏Í≥†Ìïú Ï†ïÌôïÌïú Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
        async function fetchDataUntilPrompt(timeoutMs) {
            return new Promise(async (resolve, reject) => {
                let result = '';
                let line = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(result);
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 1000))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        
                        for (let i = 0; i < text.length; i++) {
                            const c = text.charAt(i);
                            
                            if (c === '\r') {
                                continue; // ignore CR
                            }
                            
                            line += c;
                            
                            if (c === '\n') {
                                result += line;
                                line = '';
                            } else if (line.endsWith('ch>')) {
                                // stop on prompt
                                completed = true;
                                break;
                            }
                        }
                    }
                } catch (error) {
                    logCommand(`‚ö†Ô∏è Read error: ${error.message}`);
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                }
                resolve(result);
            });
        }

        // Í∞ÑÎã®Ìïú Î™ÖÎ†π Ï†ÑÏÜ° (ÏùëÎãµ Î∂àÌïÑÏöî)
        async function sendCommand(command) {
            try {
                logCommand(`üì§ Simple command: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                // Î™ÖÎ†π Ï≤òÎ¶¨Î•º ÏúÑÌïú ÏßßÏùÄ ÎåÄÍ∏∞
                await sleep(100);
                
                // ÏùëÎãµÏù¥ ÏûàÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú ÏßßÏùÄ ÏãúÍ∞Ñ ÏùΩÏñ¥ÏÑú Î≤ÑÎ¶º
                try {
                    await Promise.race([
                        reader.read(),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 500))
                    ]);
                } catch (e) {
                    // ÌÉÄÏûÑÏïÑÏõÉÏù¥ÎÇò ÏóêÎü¨Îäî Î¨¥Ïãú
                }
                
                return true;
            } catch (error) {
                logCommand(`‚ö†Ô∏è Simple command "${command}" error: ${error.message}`);
                return false;
            }
        }

        // Connection cleanup
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Reader cleanup error: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Writer cleanup error: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`Port close error: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`Cleanup error: ${error.message}`);
            }
        }

        // Device connection
        async function connectDevice() {
            if (!('serial' in navigator)) {
                alert('This browser does not support Web Serial API. Please use Chrome-based browsers.');
                return;
            }

            try {
                updateConnectionStatus('connecting', 'Step 1: Selecting port...');
                
                logCommand('üîç Requesting serial port...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    if (portError.message.includes('No port selected')) {
                        logCommand('‚ö†Ô∏è User cancelled port selection');
                        updateConnectionStatus('disconnected', 'Port selection cancelled');
                        return;
                    } else {
                        logCommand(`‚ùå Port selection error: ${portError.message}`);
                        updateConnectionStatus('disconnected', `Port selection failed: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`‚úÖ Port selected: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = parseInt(selectedBaudRate);

                updateConnectionStatus('connecting', `Step 2: Connecting at ${baudRate} bps...`);
                logCommand(`üîß Baud rate: ${baudRate} bps`);

                await cleanupConnection();
                
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                logCommand(`üì° Port successfully opened (${baudRate} bps)`);

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                logCommand(`   ‚Ä¢ Reader/writer setup complete`);

                await sleep(500);

                updateConnectionStatus('connecting', `Step 3: Communication test (${baudRate} bps)`);
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    logCommand(`‚úÖ Connection successful!`);
                    updateConnectionStatus('connected', `tinySA connected (${baudRate} bps)`);
                    
                    await basicInitialize();
                    return;
                } else {
                    throw new Error('Communication test failed');
                }
                
            } catch (error) {
                updateConnectionStatus('disconnected', `Connection failed: ${error.message}`);
                logCommand(`üö® Final connection failure: ${error.message}`);
                await cleanupConnection();
            }
        }

        // Quick connection test (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú Ï∞∏Í≥†)
        async function quickConnectionTest() {
            try {
                logCommand('üîÑ Communication test starting...');
                
                await sleep(200);
                
                // Îπà Î™ÖÎ†πÏúºÎ°ú ÌîÑÎ°¨ÌîÑÌä∏ ÌôïÏù∏
                logCommand('   üì§ Test: Sending empty command');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response = await fetchDataUntilPrompt(3000);
                logCommand(`   üì• Response: "${response}" (length: ${response.length})`);
                
                // 'ch>' ÌîÑÎ°¨ÌîÑÌä∏ ÌôïÏù∏ (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏôÄ ÎèôÏùº)
                if (response.includes('ch>') || response.length === 0) {
                    logCommand('   ‚úÖ tinySA prompt confirmed or ready');
                    return true;
                } else {
                    logCommand('   ‚ö†Ô∏è Unexpected response format');
                    return response.length > 0; // ÏùëÎãµÏù¥ ÏûàÏúºÎ©¥ Ïó∞Í≤∞Îê®ÏúºÎ°ú Í∞ÑÏ£º
                }
                
            } catch (error) {
                logCommand(`‚ùå Connection test failed: ${error.message}`);
                return false;
            }
        }

        // Basic initialization (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú Ï∞∏Í≥†)
        async function basicInitialize() {
            try {
                logCommand('üîß Basic initialization starting...');
                
                await sleep(500);
                
                // resume Î™ÖÎ†πÏúºÎ°ú Ïû•ÎπÑ ÌôúÏÑ±Ìôî
                await sendCommand('resume');
                await sleep(300);
                
                logCommand('‚úÖ Basic initialization complete');
                
            } catch (error) {
                logCommand(`‚ö†Ô∏è Initialization warning: ${error.message} (normal operation possible)`);
            }
        }

        // Device disconnect
        async function disconnectDevice() {
            try {
                logCommand('üîå Disconnection starting...');
                updateConnectionStatus('connecting', 'Disconnecting...');
                
                await cleanupConnection();
                serialPort = null;
                
                updateConnectionStatus('disconnected', 'Device successfully disconnected');
                
            } catch (error) {
                logCommand(`Disconnection error: ${error.message}`);
                updateConnectionStatus('disconnected', 'Disconnected (error occurred)');
            }
        }

        // Connection diagnosis (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú Ï∞∏Í≥†)
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('‚ùå Device not connected');
                alert('Please connect device first.');
                return;
            }

            try {
                logCommand('üîç === Connection Diagnosis (Manufacturer Method) ===');
                
                // 1Îã®Í≥Ñ: Í∏∞Î≥∏ ÌÜµÏã† ÌôïÏù∏
                logCommand('1Ô∏è‚É£ Basic prompt test...');
                await writer.write(new TextEncoder().encode('\r'));
                const promptResponse = await fetchDataUntilPrompt(3000);
                logCommand(`   Prompt response: "${promptResponse}" (${promptResponse.length} chars)`);
                
                if (promptResponse.includes('ch>') || promptResponse.length === 0) {
                    logCommand('   ‚úÖ Prompt test: PASS');
                } else {
                    logCommand('   ‚ö†Ô∏è Prompt test: UNEXPECTED');
                }

                // 2Îã®Í≥Ñ: resume Î™ÖÎ†π ÌÖåÏä§Ìä∏
                logCommand('2Ô∏è‚É£ Resume command test...');
                const resumeResponse = await sendCommandAndFetchData('resume', 3000);
                logCommand(`   Resume response: "${resumeResponse || 'No response'}" (${(resumeResponse || '').length} chars)`);
                
                // 3Îã®Í≥Ñ: Í∞ÑÎã®Ìïú Îç∞Ïù¥ÌÑ∞ Î™ÖÎ†π ÌÖåÏä§Ìä∏ (Ïò®ÎèÑ Ï∏°Ï†ï)
                logCommand('3Ô∏è‚É£ Temperature reading test...');
                const tempResponse = await sendCommandAndFetchData('k', 5000);
                logCommand(`   Temperature response: "${tempResponse || 'No response'}"`);
                
                if (tempResponse && tempResponse.trim().length > 0) {
                    const tempLines = tempResponse.split('\n').filter(line => line.trim().length > 0 && !line.includes('ch>'));
                    if (tempLines.length > 0) {
                        const temp = parseFloat(tempLines[0]);
                        if (!isNaN(temp)) {
                            logCommand(`   ‚úÖ Temperature: ${temp}¬∞C - Data communication working`);
                        } else {
                            logCommand(`   ‚ö†Ô∏è Temperature parsing failed: "${tempLines[0]}"`);
                        }
                    }
                } else {
                    logCommand('   ‚ö†Ô∏è No temperature data received');
                }

                logCommand('üîç === Diagnosis Complete ===');
                logCommand('üí° If communication works but scan fails, check frequency ranges and points settings');
                
            } catch (error) {
                logCommand(`‚ùå Diagnosis error: ${error.message}`);
            }
        }

        // Clear log
        function clearLog() {
            const logElement = document.getElementById('commandLog');
            if (logElement) {
                logElement.textContent = '';
                logCommand('üìã Log cleared');
            }
        }

        // Í∞úÏÑ†Îêú Ïä§Ï∫î ÏãúÏûë Ìï®Ïàò
        async function startScan() {
            if (isScanning) {
                logCommand('‚ùå Cannot start scan: Already scanning');
                return;
            }
            
            const scanBtn = document.getElementById('scanBtn');
            scanBtn.disabled = true;
            scanBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Scanning...';
            
            isScanning = true;
            scanAborted = false;
            showProgress();
            updateProgress(0, 'Initializing scan...');
            
            logCommand('üîÑ Spectrum scan starting...');
            updateDebugInfo('Scan in progress...');
            
            try {
                // Ï∞®Ìä∏ ÏôÑÏ†Ñ Î¶¨ÏÖã
                logCommand('üîÑ Complete chart reset...');
                resetChartCompletely();
                updateProgress(5, 'Chart reset complete...');
                
                await sleep(200);
                
                // Ï∞®Ìä∏ Ïû¨Ï¥àÍ∏∞Ìôî
                logCommand('üìà Chart reinitialization...');
                await initChart();
                updateProgress(10, 'Chart reinitialized...');
                
                updateConnectionStatus('scanning', 'Scanning spectrum...');
                
                // ÌïòÎìúÏõ®Ïñ¥ Ïó∞Í≤∞Îêú Í≤ΩÏö∞
                if (isConnected) {
                    logCommand('üîó Receiving data from hardware...');
                    updateProgress(15, 'Hardware scan in progress...');
                    
                    try {
                        const data = await getHardwareSpectrum();
                        
                        if (data && data.frequencies && data.frequencies.length > 0) {
                            logCommand(`‚úÖ Hardware data reception successful: ${data.frequencies.length} points`);
                            updateProgress(90, 'Processing hardware data...');
                            await updateChart(data);
                            updateProgress(100, 'Hardware scan complete');
                            logCommand('‚úÖ Hardware scan successful');
                            return;
                        } else {
                            logCommand('‚ö†Ô∏è Invalid hardware data, switching to test data');
                        }
                    } catch (hwError) {
                        logCommand(`‚ùå Hardware scan failed: ${hwError.message}`);
                        updateProgress(20, 'Hardware scan failed, using test data...');
                    }
                }
                
                // ÌïòÎìúÏõ®Ïñ¥ ÏóÜÍ±∞ÎÇò Ïã§Ìå®Ìïú Í≤ΩÏö∞ - ÌÖåÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                logCommand('üéØ Generating test data...');
                updateProgress(30, 'Generating test data...');
                await sleep(500); // Ïä§Ï∫î ÏãúÍ∞Ñ ÏãúÎÆ¨Î†àÏù¥ÏÖò
                
                const data = generateTestData();
                updateProgress(70, 'Processing test data...');
                await sleep(300);
                
                await updateChart(data);
                updateProgress(100, 'Test scan complete');
                
                logCommand('‚úÖ Test data scan successful');
                
            } catch (error) {
                const errorMsg = `Scan error: ${error.message}`;
                document.getElementById('statusDisplay').textContent = errorMsg;
                logCommand(`‚ùå Scan failed: ${errorMsg}`);
                updateDebugInfo(`Scan failed: ${error.message}`);
                updateProgress(0, 'Scan failed');
                
            } finally {
                isScanning = false;
                scanBtn.disabled = false;
                scanBtn.innerHTML = '<i class="fas fa-search"></i> Start Scan';
                updateConnectionStatus(isConnected ? 'connected' : 'disconnected', '');
                hideProgress();
                logCommand('üèÅ Scan process ended');
            }
        }

        // Enhanced test data generation
        function generateTestData() {
            try {
                logCommand('üéØ Test data generation...');
                
                const startFreq = parseFloat(document.getElementById('startFreq').value) || 1;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) || 900;
                const points = parseInt(document.getElementById('scanPoints').value) || 101;
                
                logCommand(`   Parameters: ${startFreq}-${stopFreq} MHz, ${points} points`);
                
                if (startFreq >= stopFreq) {
                    throw new Error('Start frequency must be less than stop frequency');
                }
                
                const step = (stopFreq - startFreq) / (points - 1);
                const freqs = [];
                const spectrum = [];
                
                // Í∏∞Î≥∏ ÎÖ∏Ïù¥Ï¶à ÌîåÎ°úÏñ¥ ÏÑ§Ï†ï
                const baseNoiseLevel = -90;
                const noiseVariation = 8;
                
                for (let i = 0; i < points; i++) {
                    const freq = startFreq + i * step;
                    
                    // Í∏∞Î≥∏ ÎÖ∏Ïù¥Ï¶à ÌîåÎ°úÏñ¥ (ÎûúÎç§ ÎÖ∏Ïù¥Ï¶à + Ï£ºÌååÏàò Ï¢ÖÏÜç Î≥ÄÎèô)
                    let amp = baseNoiseLevel + 
                             (Math.random() - 0.5) * noiseVariation +
                             Math.sin(freq * 0.01) * 3; // ÏïΩÍ∞ÑÏùò Ï£ºÌååÏàò Ï¢ÖÏÜç Î≥ÄÎèô
                    
                    // Îã§Ï§ë Ïã†Ìò∏ Ï∂îÍ∞Ä (Îçî ÌòÑÏã§Ï†ÅÏù∏ ÌòïÌÉú)
                    
                    // FM Î∞©ÏÜ° ÎåÄÏó≠ (88-108 MHz) ÏãúÎÆ¨Î†àÏù¥ÏÖò
                    if (freq >= 88 && freq <= 108) {
                        for (let fm = 88.1; fm <= 107.9; fm += 0.2) {
                            if (Math.abs(freq - fm) < 0.1) {
                                amp = Math.max(amp, -25 + (Math.random() - 0.5) * 10);
                            }
                        }
                    }
                    
                    // Î™®Î∞îÏùº Í∏∞ÏßÄÍµ≠ Ïã†Ìò∏ (1800-1900 MHz)
                    if (freq >= 1800 && freq <= 1900) {
                        amp = Math.max(amp, -45 + (Math.random() - 0.5) * 15);
                    }
                    
                    // WiFi 2.4GHz ÎåÄÏó≠
                    if (Math.abs(freq - 2412) < 5 || Math.abs(freq - 2437) < 5 || Math.abs(freq - 2462) < 5) {
                        amp = Math.max(amp, -35 - Math.abs(freq % 25) * 2);
                    }
                    
                    // ÏïÑÎßàÏ∂îÏñ¥ Î¨¥ÏÑ† ÎåÄÏó≠
                    const hamBands = [14.2, 21.2, 28.5, 50.1, 144.1, 432.1, 1296.1];
                    hamBands.forEach(hamFreq => {
                        if (Math.abs(freq - hamFreq) < 1) {
                            amp = Math.max(amp, -40 - Math.abs(freq - hamFreq) * 15);
                        }
                    });
                    
                    // ISM ÎåÄÏó≠ (433 MHz, 868 MHz, 915 MHz)
                    if (Math.abs(freq - 433.92) < 2) {
                        amp = Math.max(amp, -38 - Math.abs(freq - 433.92) * 8);
                    }
                    if (Math.abs(freq - 868) < 3) {
                        amp = Math.max(amp, -42 - Math.abs(freq - 868) * 6);
                    }
                    if (Math.abs(freq - 915) < 3) {
                        amp = Math.max(amp, -40 - Math.abs(freq - 915) * 7);
                    }
                    
                    // ÎûúÎç§ Ïä§Ìì®Î¶¨Ïñ¥Ïä§ Ïã†Ìò∏
                    if (Math.random() < 0.02) { // 2% ÌôïÎ•†Î°ú ÎûúÎç§ Ïã†Ìò∏
                        amp = Math.max(amp, -60 + Math.random() * 20);
                    }
                    
                    // ÌïòÎ™®Îãâ Ïã†Ìò∏ (Í∏∞Î≥∏ Ïã†Ìò∏Ïùò Î∞∞Ïàò Ï£ºÌååÏàòÏóêÏÑú)
                    const fundamentals = [100, 433.92, 868];
                    fundamentals.forEach(fund => {
                        for (let harmonic = 2; harmonic <= 5; harmonic++) {
                            if (Math.abs(freq - fund * harmonic) < 1) {
                                const harmonicLevel = -45 - harmonic * 6;
                                amp = Math.max(amp, harmonicLevel - Math.abs(freq - fund * harmonic) * 10);
                            }
                        }
                    });
                    
                    freqs.push(freq);
                    spectrum.push(Math.max(amp, -110)); // ÏµúÏÜåÍ∞í Ï†úÌïú
                }
                
                logCommand(`‚úÖ ${freqs.length} realistic test data points generated`);
                logCommand(`   Signal distribution: Noise floor ${baseNoiseLevel}dBm, Max signal ${Math.max(...spectrum).toFixed(1)}dBm`);
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`‚ùå Test data generation error: ${error.message}`);
                
                // ÏµúÏÜå Ìè¥Î∞± Îç∞Ïù¥ÌÑ∞
                return {
                    frequencies: [1, 100, 200, 500, 900],
                    spectrum: [-90, -40, -60, -50, -80]
                };
            }
        }

        // Í∞úÏÑ†Îêú Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò (ÏôÑÏ†ÑÌïú Î¶¨ÌîÑÎ†àÏãú)
        async function updateChart(data) {
            try {
                logCommand('üìà Chart update starting...');
                updateDebugInfo('Updating chart...');
                
                if (!chart || !chartInitialized) {
                    logCommand('‚ö†Ô∏è Chart object missing. Reinitializing...');
                    await initChart();
                }
                
                if (!data || !data.frequencies || !data.spectrum) {
                    throw new Error('Invalid data format');
                }
                
                if (data.frequencies.length !== data.spectrum.length) {
                    throw new Error('Frequency and spectrum data length mismatch');
                }
                
                if (data.frequencies.length === 0) {
                    throw new Error('Data is empty');
                }
                
                logCommand(`   Data validation complete: ${data.frequencies.length} points`);
                logCommand(`   Frequency range: ${data.frequencies[0].toFixed(2)} - ${data.frequencies[data.frequencies.length-1].toFixed(2)} MHz`);
                logCommand(`   Amplitude range: ${Math.min(...data.spectrum).toFixed(1)} - ${Math.max(...data.spectrum).toFixed(1)} dBm`);
                
                // Í∏ÄÎ°úÎ≤å Î≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏ (ÍπäÏùÄ Î≥µÏÇ¨)
                frequencies = [...data.frequencies];
                spectrumData = [...data.spectrum];
                
                // ÏûêÎèô Ï∞®Ìä∏ Ïä§ÏºÄÏùº Ï°∞Ï†ï
                const minAmp = Math.min(...data.spectrum);
                const maxAmp = Math.max(...data.spectrum);
                const ampRange = maxAmp - minAmp;
                const padding = Math.max(ampRange * 0.1, 5); // 10% Ìå®Îî©, ÏµúÏÜå 5dB
                
                // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏôÑÏ†Ñ ÍµêÏ≤¥
                logCommand('   Complete chart data replacement...');
                chart.data.labels = [];
                chart.data.datasets[0].data = [];
                
                // Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÜÏù¥)
                chart.update('none');
                
                // ÏÉà Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
                chart.data.labels = data.frequencies.map(f => f.toFixed(1));
                chart.data.datasets[0].data = [...data.spectrum];
                
                // YÏ∂ï Î≤îÏúÑ ÏûêÎèô Ï°∞Ï†ï
                chart.options.scales.y.min = Math.max(-120, minAmp - padding);
                chart.options.scales.y.max = Math.min(20, maxAmp + padding);
                
                // Ï∞®Ìä∏ Í∞ïÏ†ú ÏôÑÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
                logCommand('   Starting chart rendering...');
                chart.update('active');
                
                // Î†åÎçîÎßÅ ÏôÑÎ£å ÎåÄÍ∏∞
                await new Promise(resolve => {
                    const onAnimationComplete = () => {
                        chart.options.animation.onComplete = null;
                        resolve();
                    };
                    
                    chart.options.animation.onComplete = onAnimationComplete;
                    
                    // ÏïàÏ†Ñ ÌÉÄÏûÑÏïÑÏõÉ: ÏµúÎåÄ 3Ï¥à ÎåÄÍ∏∞
                    setTimeout(resolve, 3000);
                });
                
                // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                const statusMsg = `Scan complete - ${data.frequencies.length} points, Range: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                document.getElementById('statusDisplay').textContent = statusMsg;
                
                updateDebugInfo('Chart update complete');
                logCommand('‚úÖ Chart update successful');
                
                // Ï∞®Ìä∏ Î†åÎçîÎßÅ ÌôïÏù∏
                const canvas = document.getElementById('spectrumChart');
                if (canvas) {
                    logCommand(`   Final confirmation: Canvas size ${canvas.width}x${canvas.height}, Data ${chart.data.datasets[0].data.length} points`);
                }
                
            } catch (error) {
                logCommand(`‚ùå Chart update failed: ${error.message}`);
                updateDebugInfo(`Chart update failed: ${error.message}`);
                throw error;
            }
        }

        // Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÎ•º Ï∞∏Í≥†Ìïú ÏôÑÏ†ÑÌûà ÏÉàÎ°úÏö¥ ÌïòÎìúÏõ®Ïñ¥ Ïä§ÌéôÌä∏Îüº Ï∏°Ï†ï
        async function getHardwareSpectrum() {
            try {
                const startFreq = parseFloat(document.getElementById('startFreq').value) * 1e9; // GHz to Hz
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) * 1e9; // GHz to Hz
                const points = parseInt(document.getElementById('scanPoints').value);

                logCommand('üì° === Hardware Spectrum Measurement (New Method) ===');
                logCommand(`Parameters: ${startFreq/1e9} - ${stopFreq/1e9} GHz, ${points} points`);

                updateProgress(15, 'Pausing device...');
                
                // 1Îã®Í≥Ñ: Ïû•ÎπÑ ÏùºÏãúÏ†ïÏßÄ (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏôÄ ÎèôÏùº)
                await sendCommand('pause');
                await sleep(500);

                updateProgress(25, 'Sending scan command...');
                
                // 2Îã®Í≥Ñ: scan Î™ÖÎ†π Ï†ÑÏÜ° (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏùò ÌïµÏã¨ Î™ÖÎ†π)
                const scanCommand = `scan ${Math.floor(startFreq)} ${Math.floor(stopFreq)} ${points}`;
                logCommand(`   Scan command: ${scanCommand}`);
                await sendCommand(scanCommand);
                
                // Ïä§Ï∫î ÏãúÍ∞Ñ Í≥ÑÏÇ∞ Î∞è ÎåÄÍ∏∞
                const scanTime = Math.max(3000, points * 30); // Ìè¨Ïù∏Ìä∏Îãπ 30ms, ÏµúÏÜå 3Ï¥à
                const maxScanTime = Math.min(scanTime, 30000); // ÏµúÎåÄ 30Ï¥à
                
                logCommand(`   Calculated scan time: ${maxScanTime}ms`);
                
                // Ïä§Ï∫î ÏôÑÎ£å ÎåÄÍ∏∞ (ÏßÑÌñâÎ•† ÌëúÏãú)
                const progressSteps = 10;
                const stepTime = maxScanTime / progressSteps;
                
                for (let i = 0; i < progressSteps; i++) {
                    if (scanAborted) {
                        throw new Error('Scan aborted by user');
                    }
                    
                    const progress = 25 + (i + 1) * 4; // 25%ÏóêÏÑú 65%ÍπåÏßÄ
                    updateProgress(progress, `Scanning... ${i+1}/${progressSteps}`);
                    await sleep(stepTime);
                }

                updateProgress(70, 'Reading frequencies...');
                
                // 3Îã®Í≥Ñ: Ï£ºÌååÏàò Î¶¨Ïä§Ìä∏ ÏùΩÍ∏∞ (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏôÄ ÎèôÏùº)
                logCommand('   üì§ Fetching frequencies...');
                const freqResponse = await sendCommandAndFetchData('frequencies', 15000);
                
                if (!freqResponse) {
                    throw new Error('Failed to get frequency data');
                }

                updateProgress(80, 'Reading signal data...');
                
                // 4Îã®Í≥Ñ: Ïã†Ìò∏ÏÑ∏Í∏∞ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú: data 0)
                logCommand('   üì§ Fetching signal data...');
                const dataResponse = await sendCommandAndFetchData('data 0', 15000);
                
                if (!dataResponse) {
                    throw new Error('Failed to get signal data');
                }

                updateProgress(85, 'Processing data...');
                
                // 5Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞ ÌååÏã± (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìú Î∞©Ïãù Ï†ÅÏö©)
                logCommand('   üìä Parsing frequency data...');
                const freqLines = freqResponse.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !line.includes('ch>'))
                    .map(line => {
                        const freq = parseFloat(line);
                        return isNaN(freq) ? null : freq;
                    })
                    .filter(freq => freq !== null);

                logCommand('   üìä Parsing signal data...');
                const dataLines = dataResponse.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !line.includes('ch>'))
                    .map(line => {
                        const amplitude = parseFloat(line);
                        return isNaN(amplitude) ? null : amplitude;
                    })
                    .filter(amplitude => amplitude !== null);

                logCommand(`   ‚úÖ Parsed: ${freqLines.length} frequencies, ${dataLines.length} amplitudes`);
                
                if (freqLines.length === 0 || dataLines.length === 0) {
                    throw new Error('No valid data received');
                }

                // 6Îã®Í≥Ñ: Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Î∞è Ï†ïÎ¶¨
                const minLength = Math.min(freqLines.length, dataLines.length);
                
                if (minLength < points * 0.5) { // ÏµúÏÜå 50% Ïù¥ÏÉÅÏùò Îç∞Ïù¥ÌÑ∞ ÌïÑÏöî
                    logCommand(`‚ö†Ô∏è Warning: Only received ${minLength} points, expected ${points}`);
                }
                
                const freqs = freqLines.slice(0, minLength).map(freq => freq / 1e9); // Hz to GHz
                const spectrum = dataLines.slice(0, minLength);

                // 7Îã®Í≥Ñ: Ïû•ÎπÑ Ïû¨Í∞ú (Ï†úÏ°∞ÏÇ¨ ÏΩîÎìúÏôÄ ÎèôÏùº)
                await sendCommand('resume');

                logCommand('üì° === Hardware Measurement Complete ===');
                logCommand(`   üìä Final result: ${freqs.length} points`);
                logCommand(`   üìà Frequency range: ${freqs[0]?.toFixed(3)} - ${freqs[freqs.length-1]?.toFixed(3)} GHz`);
                logCommand(`   üìä Signal range: ${Math.min(...spectrum).toFixed(1)} - ${Math.max(...spectrum).toFixed(1)} dBm`);
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`‚ùå Hardware scan error: ${error.message}`);
                
                // Ïò§Î•ò Î∞úÏÉù Ïãú Ïû•ÎπÑ Ïû¨Í∞ú ÏãúÎèÑ
                try {
                    await sendCommand('resume');
                } catch (resumeError) {
                    logCommand(`‚ö†Ô∏è Failed to resume after error: ${resumeError.message}`);
                }
                
                throw error;
            }
        }

        // Update marker
        function updateMarker(frequency, amplitude) {
            const markerElement = document.getElementById('markerInfo');
            if (markerElement) {
                markerElement.innerHTML = `
                    <strong>Frequency:</strong> ${frequency.toFixed(2)} MHz<br>
                    <strong>Amplitude:</strong> ${amplitude.toFixed(1)} dBm
                `;
            }
        }

        // CSV download
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('Please run a scan first.');
                return;
            }

            let csvContent = "Frequency(MHz),Signal_Strength(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Enhanced page load initialization
        window.addEventListener('load', async function() {
            logCommand('üöÄ === System Initialization (Manufacturer Compatible) ===');
            
            try {
                // ÌÖåÎßà Ï¥àÍ∏∞Ìôî
                initTheme();
                
                updateDebugInfo('System initializing...');
                
                // Chart.js ÎùºÏù¥Î∏åÎü¨Î¶¨ ÌôïÏù∏
                if (typeof Chart === 'undefined') {
                    logCommand('‚ùå Chart.js library not loaded');
                    updateDebugInfo('Chart.js library load failed');
                    return;
                }
                
                logCommand('‚úÖ Chart.js library loaded successfully');
                
                // DOM ÏôÑÏ†Ñ Î°úÎìú ÎåÄÍ∏∞
                await new Promise(resolve => {
                    if (document.readyState === 'complete') {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve);
                    }
                });
                
                // Ï∞®Ìä∏ Ïª®ÌÖåÏù¥ÎÑà Ï§ÄÎπÑ ÎåÄÍ∏∞
                const chartContainer = document.querySelector('.chart-wrapper');
                if (chartContainer) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî
                logCommand('üîÑ Chart initialization starting...');
                await initChart();
                logCommand('‚úÖ Chart initialization successful');
                
                // Web Serial API ÌôïÏù∏
                if (!('serial' in navigator)) {
                    logCommand('‚ùå Warning: Web Serial API not supported in this browser');
                    logCommand('üîß Solution: Please use Chrome, Edge, or Opera browsers');
                    updateDebugInfo('Web Serial API not supported');
                } else {
                    logCommand('‚úÖ Web Serial API supported');
                    
                    // Ïó∞Í≤∞ Ìï¥Ï†ú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
                    navigator.serial.addEventListener('disconnect', (event) => {
                        if (event.target === serialPort) {
                            updateConnectionStatus('disconnected', 'üîå Device disconnected (check USB cable)');
                            serialPort = null;
                            reader = null;
                            writer = null;
                        }
                    });
                }
                
                // Ïï†ÎãàÎ©îÏù¥ÏÖò Ìö®Í≥º Ï∂îÍ∞Ä
                document.querySelectorAll('.card').forEach((card, index) => {
                    card.style.animationDelay = `${index * 0.1}s`;
                });
                
                // Ï∞®Ìä∏ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
                window.addEventListener('resize', () => {
                    if (chart) {
                        chart.resize();
                        logCommand('üìè Chart resized for window change');
                    }
                });
                
                // Ï¥àÍ∏∞ ÌÖåÏä§Ìä∏ Ï∞®Ìä∏ ÌëúÏãú
                setTimeout(async () => {
                    logCommand('üîÑ Loading initial test chart...');
                    await testChart();
                }, 800);
                
                logCommand('‚úÖ System initialization complete - Ready for operation');
                updateDebugInfo('System ready - Manufacturer protocol implemented');
                
            } catch (error) {
                logCommand(`‚ùå Initialization error: ${error.message}`);
                updateDebugInfo(`Initialization failed: ${error.message}`);
                console.error('Initialization error:', error);
                
                // Ïã§Ìå® Ïãú ÎåÄÏïà Ï¥àÍ∏∞Ìôî ÏãúÎèÑ
                logCommand('üîÑ Attempting alternative initialization...');
                setTimeout(async () => {
                    try {
                        await initChart();
                        await testChart();
                        logCommand('‚úÖ Alternative initialization successful');
                    } catch (retryError) {
                        logCommand(`‚ùå Alternative initialization failed: ${retryError.message}`);
                    }
                }, 2000);
            }
        });
    </script>
</body>
</html>
