<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinySA 스펙트럼 분석기 시뮬레이터</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            border-radius: 15px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4a5568;
            font-size: 14px;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ff;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #4a6cf7;
            box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 108, 247, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }

        .chart-container {
            background: #ffffff;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e1e8ff;
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
        }

        .signal-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .signal-group {
            background: #f0f7ff;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #bee3f8;
        }

        .signal-group h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .marker-info {
            background: linear-gradient(45deg, #ffd89b, #19547b);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .marker-info h3 {
            margin-bottom: 10px;
        }

        .status-bar {
            background: #2d3748;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .unit-label {
            background: #e1e8ff;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            color: #4a5568;
            display: flex;
            align-items: center;
        }

        .status-indicator {
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        .status-indicator.connected {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .status-indicator.disconnected {
            background: linear-gradient(45deg, #f56565, #e53e3e);
            color: white;
        }

        .status-indicator.connecting {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .command-log {
            background: #2d3748;
            color: #68d391;
            font-family: monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            margin-top: 15px;
            border: 2px solid #4a5568;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .signal-controls {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔬 TinySA 스펙트럼 분석기</h1>
            <p>RF 신호 분석 및 시뮬레이션 도구</p>
        </div>

        <div class="controls-grid">
            <div class="control-panel">
                <h2>🔌 장비 연결</h2>
                
                <div class="control-group">
                    <label>연결 상태</label>
                    <div id="connectionStatus" class="status-indicator disconnected">연결 안됨</div>
                </div>

                <div class="control-group">
                    <label>장비 모드</label>
                    <select id="deviceMode">
                        <option value="simulation">시뮬레이션 모드</option>
                        <option value="hardware">실제 장비 연결</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>보드레이트 (bps)</label>
                    <select id="baudRate">
                        <option value="auto">자동 감지 (권장)</option>
                        <option value="9600" selected>9600 (시스템 기본)</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200">115200 (tinySA 표준)</option>
                        <option value="230400">230400</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="connectBtn" onclick="connectDevice()">🔌 장비 연결</button>
                    <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnectDevice()" disabled>❌ 연결 해제</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="diagnoseConnection()" id="diagnoseBtn" disabled>🔍 연결 진단</button>
                    <button class="btn btn-secondary" onclick="clearLog()">🗑️ 로그 지우기</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="quickReconnect()" id="reconnectBtn" disabled>🔄 빠른 재연결</button>
                    <button class="btn btn-secondary" onclick="resetConnection()">🔧 연결 리셋</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="fullDiagnosis()">🔬 전체 진단</button>
                    <button class="btn btn-secondary" onclick="monitorRawData()">📡 원시 데이터 모니터</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="checkUSBDevices()">🔍 USB 장치 확인</button>
                    <button class="btn btn-secondary" onclick="fixPortIssues()">🔧 포트 문제 해결</button>
                </div>

                <hr style="margin: 20px 0; border: 1px solid #e1e8ff;">

                <h2>📡 주파수 설정</h2>
                
                <div class="control-group">
                    <label>시작 주파수</label>
                    <div class="input-group">
                        <input type="number" id="startFreq" value="1" step="0.1">
                        <span class="unit-label">MHz</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>종료 주파수</label>
                    <div class="input-group">
                        <input type="number" id="stopFreq" value="900" step="0.1">
                        <span class="unit-label">MHz</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>스캔 포인트</label>
                    <select id="scanPoints">
                        <option value="101">101</option>
                        <option value="201">201</option>
                        <option value="301">301</option>
                        <option value="501">501</option>
                        <option value="801">801</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>RBW (Resolution Bandwidth)</label>
                    <select id="rbw">
                        <option value="auto">Auto</option>
                        <option value="1">1 kHz</option>
                        <option value="3">3 kHz</option>
                        <option value="10">10 kHz</option>
                        <option value="30">30 kHz</option>
                        <option value="100">100 kHz</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="startScan()">🔍 스캔 시작</button>
                    <button class="btn btn-secondary" onclick="downloadCSV()">💾 CSV 저장</button>
                </div>

                <div class="marker-info">
                    <h3>📍 마커 정보</h3>
                    <div id="markerInfo">클릭으로 마커 설정</div>
                </div>

                <div class="control-group">
                    <label>명령어 로그</label>
                    <div id="commandLog" class="command-log">시스템 준비 완료...\n</div>
                </div>
            </div>

            <div class="chart-container">
                <h2>📊 스펙트럼 분석</h2>
                <div class="chart-wrapper">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>

        <div class="signal-controls">
            <div class="signal-group">
                <h3>🎯 신호 1 설정</h3>
                <div class="control-group">
                    <label>주파수 (MHz)</label>
                    <input type="number" id="signal1Freq" value="100" step="0.1">
                </div>
                <div class="control-group">
                    <label>진폭 (dBm)</label>
                    <input type="number" id="signal1Amp" value="-20" step="1">
                </div>
                <div class="control-group">
                    <label>신호 타입</label>
                    <select id="signal1Type">
                        <option value="sine">사인파</option>
                        <option value="square">구형파</option>
                        <option value="noise">노이즈</option>
                    </select>
                </div>
            </div>

            <div class="signal-group">
                <h3>🎯 신호 2 설정</h3>
                <div class="control-group">
                    <label>주파수 (MHz)</label>
                    <input type="number" id="signal2Freq" value="200" step="0.1">
                </div>
                <div class="control-group">
                    <label>진폭 (dBm)</label>
                    <input type="number" id="signal2Amp" value="-30" step="1">
                </div>
                <div class="control-group">
                    <label>신호 타입</label>
                    <select id="signal2Type">
                        <option value="sine">사인파</option>
                        <option value="square">구형파</option>
                        <option value="noise">노이즈</option>
                    </select>
                </div>
            </div>

            <div class="signal-group">
                <h3>🔧 고급 설정</h3>
                <div class="control-group">
                    <label>출력 레벨 (dBm)</label>
                    <input type="number" id="outputLevel" value="-10" step="1">
                </div>
                <div class="control-group">
                    <label>출력 모드</label>
                    <select id="outputMode">
                        <option value="off">OFF</option>
                        <option value="on">ON</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>입력 모드</label>
                    <select id="inputMode">
                        <option value="low">Low Input</option>
                        <option value="high">High Input</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="applyAdvancedSettings()" style="width: 100%; margin-top: 10px;">⚙️ 설정 적용</button>
            </div>

            <div class="signal-group">
                <h3>🔊 노이즈 & 상태</h3>
                <div class="control-group">
                    <label>노이즈 레벨 (dBm)</label>
                    <input type="number" id="noiseLevel" value="-80" step="1">
                </div>
                <div class="control-group">
                    <label>온도 (°C)</label>
                    <input type="number" id="temperature" value="25" step="1" readonly>
                </div>
                <button class="btn btn-secondary" onclick="getTemperature()" style="width: 100%; margin-top: 10px;">🌡️ 온도 측정</button>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusDisplay">시스템 준비 완료 - 스캔을 시작하세요</div>
        </div>

        <div class="control-panel" style="margin-top: 20px;">
            <h2>🚨 USB 인식 문제 해결</h2>
            <div style="background: #f8f9ff; padding: 15px; border-radius: 10px; font-size: 14px; line-height: 1.6;">
                <div style="background: #d4edda; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                    <strong>✅ 현재 상황 분석:</strong><br>
                    • 에러 메시지: "Chooser dialog blocked by Serial blocklist"<br>
                    • 차단된 장치: "진욱의 AirPods Pro" (블루투스)<br>
                    • <strong>실제 문제: tinySA USB 장치가 시스템에서 인식되지 않음</strong>
                </div>

                <strong>🔧 즉시 해결 방법 (우선순위 순):</strong><br>
                
                <div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 5px;">
                    <strong>1️⃣ USB 케이블 교체 (가장 중요)</strong><br>
                    • 현재 케이블이 <strong>충전 전용</strong>일 가능성 높음<br>
                    • <strong>데이터 전송용</strong> USB-A to USB-C 또는 USB-A to Micro-USB 케이블 사용<br>
                    • 스마트폰 데이터 케이블 또는 외장하드 케이블 사용 권장<br>
                    • 케이블 길이는 1m 이하로 제한
                </div>
                
                <div style="margin: 10px 0; padding: 10px; background: #d1ecf1; border-radius: 5px;">
                    <strong>2️⃣ Windows 장치 관리자 확인</strong><br>
                    • <code>Win + X</code> → <strong>장치 관리자</strong> 열기<br>
                    • <strong>"포트(COM 및 LPT)"</strong> 섹션 확인<br>
                    • <strong>"USB Serial Port (COMx)"</strong> 또는 <strong>"STM32 Virtual ComPort"</strong> 찾기<br>
                    • 없다면 <strong>"기타 장치"</strong>에서 느낌표(!) 표시된 장치 확인<br>
                    • 해당 장치 우클릭 → <strong>"드라이버 업데이트"</strong> 시도
                </div>
                
                <div style="margin: 10px 0; padding: 10px; background: #f8d7da; border-radius: 5px;">
                    <strong>3️⃣ USB 포트 변경</strong><br>
                    • <strong>USB 2.0 포트</strong> 사용 (USB 3.0보다 안정적)<br>
                    • <strong>컴퓨터 뒷면의 USB 포트</strong> 우선 사용<br>
                    • USB 허브 사용 금지, <strong>직접 연결</strong><br>
                    • 다른 USB 장치들을 분리하고 테스트
                </div>

                <div style="margin: 10px 0; padding: 10px; background: #e2e3e5; border-radius: 5px;">
                    <strong>4️⃣ tinySA 재부팅</strong><br>
                    • tinySA 전원 버튼으로 <strong>완전히 종료</strong><br>
                    • <strong>10초 대기</strong> 후 다시 전원 켜기<br>
                    • 화면에 정상적인 스펙트럼이 표시되는지 확인<br>
                    • USB 연결 후 화면 변화 확인
                </div>

                <strong>🔍 문제 해결 순서:</strong><br>
                1. 위 1~4번 모두 시도<br>
                2. <strong>"USB 장치 확인"</strong> 버튼으로 시스템 상태 점검<br>
                3. 장치 관리자에서 COM 포트 확인됨 → 브라우저에서 연결 재시도<br>
                4. 여전히 안 되면 <strong>"포트 문제 해결"</strong> 상세 가이드 확인<br><br>

                <strong>💡 성공 지표:</strong><br>
                • 장치 관리자에 <strong>"USB Serial Port (COM숫자)"</strong> 표시<br>
                • 브라우저 포트 선택 시 <strong>AirPods 대신 USB 장치</strong> 표시<br>
                • 연결 시도 시 <strong>블록리스트 에러 없음</strong>
            </div>
        </div>

        <div class="control-panel" style="margin-top: 20px;">
            <h2>🔧 고급 문제 해결</h2>
            <div style="background: #f8f9ff; padding: 15px; border-radius: 10px; font-size: 14px; line-height: 1.6;">
                <strong>Windows 고급 해결법:</strong><br>
                
                <div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 5px;">
                    <strong>📋 수동 드라이버 설치:</strong><br>
                    1. 장치 관리자에서 <strong>알 수 없는 장치</strong> 우클릭<br>
                    2. <strong>"드라이버 업데이트"</strong> → <strong>"컴퓨터에서 드라이버 찾아보기"</strong><br>
                    3. <strong>"컴퓨터의 사용 가능한 드라이버 목록에서 선택"</strong><br>
                    4. <strong>"포트(COM 및 LPT)"</strong> → <strong>"USB Serial Port"</strong> 선택
                </div>
                
                <div style="margin: 10px 0; padding: 10px; background: #d1ecf1; border-radius: 5px;">
                    <strong>⚡ USB 전원 관리 해제:</strong><br>
                    1. 제어판 → <strong>전원 옵션</strong> → <strong>고급 전원 설정</strong><br>
                    2. <strong>"USB 설정"</strong> → <strong>"USB 선택적 일시 중단 설정"</strong><br>
                    3. <strong>"사용 안 함"</strong>으로 변경 후 저장
                </div>

                <strong>대체 연결 방법:</strong><br>
                • <strong>다른 컴퓨터에서 테스트</strong> (하드웨어 문제 확인용)<br>
                • <strong>tinySA 공식 소프트웨어</strong>로 연결 테스트<br>
                • <strong>터미널 프로그램</strong> (PuTTY, Tera Term)으로 직접 연결 시도<br>
                • <strong>Arduino IDE Serial Monitor</strong>로 테스트
            </div>
        </div>
    </div>

    <script>
        let chart;
        let spectrumData = [];
        let frequencies = [];
        let isScanning = false;
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;

        // tinySA 장비 식별자
        const TINYSA_VID = 0x0483; // 1155
        const TINYSA_PID = 0x5740; // 22336

        // 슬립 함수 (최상단에 정의)
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 로그 출력 함수 (콘솔과 UI 모두)
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            // UI에 로그 추가
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            // 브라우저 콘솔에도 로그 (디버깅용)
            if (message.includes('❌') || message.includes('오류') || message.includes('실패')) {
                console.error('tinySA:', message);
            } else if (message.includes('⚠️') || message.includes('경고')) {
                console.warn('tinySA:', message);
            } else if (message.includes('✅') || message.includes('성공')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // 연결 상태 업데이트
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            const reconnectBtn = document.getElementById('reconnectBtn');
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.textContent = '연결됨 ✓';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    diagnoseBtn.disabled = false;
                    reconnectBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.textContent = '연결 안됨';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    diagnoseBtn.disabled = true;
                    reconnectBtn.disabled = serialPort ? false : true; // 이전 연결 정보가 있으면 재연결 가능
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.textContent = '연결 중...';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = true;
                    diagnoseBtn.disabled = true;
                    reconnectBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }

        // 빠른 재연결
        async function quickReconnect() {
            if (!serialPort) {
                logCommand('❌ 이전 연결 정보가 없습니다. 새로 연결하세요.');
                return;
            }

            try {
                logCommand('🔄 빠른 재연결 시도...');
                updateConnectionStatus('connecting', '빠른 재연결 중...');
                
                // 기존 연결 정리
                await cleanupConnection();
                
                // 현재 선택된 보드레이트 사용
                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = selectedBaudRate === 'auto' ? 9600 : parseInt(selectedBaudRate);
                
                logCommand(`🔧 재연결 보드레이트: ${baudRate} bps`);
                
                // 이전과 같은 포트로 재연결 시도
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();

                await sleep(300);
                
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    updateConnectionStatus('connected', `빠른 재연결 성공! (${baudRate} bps)`);
                    await basicInitialize();
                } else {
                    throw new Error('통신 테스트 실패');
                }
                
            } catch (error) {
                logCommand(`❌ 빠른 재연결 실패: ${error.message}`);
                updateConnectionStatus('disconnected', '빠른 재연결 실패 - 새로 연결하세요');
                await cleanupConnection();
            }
        }

        // 연결 리셋
        async function resetConnection() {
            try {
                logCommand('🔧 연결 리셋 시작...');
                
                // 모든 연결 정보 초기화
                await cleanupConnection();
                serialPort = null;
                reader = null;
                writer = null;
                
                updateConnectionStatus('disconnected', '연결이 완전히 리셋되었습니다');
                logCommand('✅ 연결 리셋 완료 - 새로 연결할 수 있습니다');
                
            } catch (error) {
                logCommand(`리셋 오류: ${error.message}`);
            }
        }

        // 전체 시스템 진단
        async function fullDiagnosis() {
            logCommand('🔬 === 전체 시스템 진단 시작 ===');
            
            // 1. 브라우저 환경 점검
            logCommand('');
            logCommand('1️⃣ 브라우저 환경 점검');
            logCommand(`   • 브라우저: ${navigator.userAgent.split(' ').pop()}`);
            logCommand(`   • Web Serial API: ${('serial' in navigator) ? '✅ 지원됨' : '❌ 지원 안됨'}`);
            logCommand(`   • HTTPS/localhost: ${(location.protocol === 'https:' || location.hostname === 'localhost') ? '✅ 안전한 연결' : '⚠️ 보안 연결 필요'}`);
            
            // 2. 시리얼 포트 권한 확인
            logCommand('');
            logCommand('2️⃣ 시리얼 포트 권한 확인');
            try {
                const ports = await navigator.serial.getPorts();
                logCommand(`   • 기존 허용된 포트: ${ports.length}개`);
                ports.forEach((port, index) => {
                    const info = port.getInfo();
                    logCommand(`     ${index+1}. VID=0x${info.usbVendorId?.toString(16) || '????'}, PID=0x${info.usbProductId?.toString(16) || '????'}`);
                });
                
                if (ports.length === 0) {
                    logCommand('   ⚠️ 허용된 포트가 없습니다. "장비 연결" 버튼으로 포트를 선택하세요.');
                }
            } catch (error) {
                logCommand(`   ❌ 포트 권한 확인 실패: ${error.message}`);
            }

            // 3. 현재 연결 상태 분석
            logCommand('');
            logCommand('3️⃣ 현재 연결 상태');
            logCommand(`   • 연결 상태: ${isConnected ? '✅ 연결됨' : '❌ 연결 안됨'}`);
            logCommand(`   • 시리얼 포트: ${serialPort ? '✅ 포트 객체 존재' : '❌ 포트 없음'}`);
            logCommand(`   • Reader: ${reader ? '✅ 활성' : '❌ 비활성'}`);
            logCommand(`   • Writer: ${writer ? '✅ 활성' : '❌ 비활성'}`);
            
            if (serialPort) {
                try {
                    const portInfo = serialPort.getInfo();
                    logCommand(`   • 포트 정보: VID=0x${portInfo.usbVendorId?.toString(16)}, PID=0x${portInfo.usbProductId?.toString(16)}`);
                    logCommand(`   • 포트 상태: ${serialPort.readable ? '✅ 읽기 가능' : '❌ 읽기 불가'}`);
                    logCommand(`   • 쓰기 상태: ${serialPort.writable ? '✅ 쓰기 가능' : '❌ 쓰기 불가'}`);
                } catch (error) {
                    logCommand(`   ❌ 포트 정보 읽기 실패: ${error.message}`);
                }
            }

            // 4. 보드레이트 및 설정 확인
            logCommand('');
            logCommand('4️⃣ 통신 설정 확인');
            const selectedBaudRate = document.getElementById('baudRate').value;
            logCommand(`   • 선택된 보드레이트: ${selectedBaudRate}`);
            logCommand(`   • 장비 모드: ${document.getElementById('deviceMode').value}`);

            // 5. 연결 테스트 (연결된 경우)
            if (isConnected && serialPort && reader && writer) {
                logCommand('');
                logCommand('5️⃣ 통신 테스트');
                await detailedConnectionTest();
            } else {
                logCommand('');
                logCommand('5️⃣ 통신 테스트');
                logCommand('   ⚠️ 장비가 연결되지 않아 통신 테스트를 건너뜁니다.');
                logCommand('   💡 먼저 "장비 연결" 후 진단을 다시 실행하세요.');
            }

            // 6. 문제 해결 제안
            logCommand('');
            logCommand('6️⃣ 문제 해결 제안');
            
            if (!('serial' in navigator)) {
                logCommand('   🔧 Chrome 기반 브라우저 사용 필요');
            } else if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                logCommand('   🔧 HTTPS 또는 localhost에서 실행 필요');
            } else if (!isConnected) {
                logCommand('   🔧 연결 시도 단계:');
                logCommand('      1. tinySA 전원 확인 및 USB 케이블 교체');
                logCommand('      2. 보드레이트를 9600으로 설정 후 연결');
                logCommand('      3. 장치 관리자에서 COM 포트 상태 확인');
                logCommand('      4. 다른 프로그램에서 포트 사용 중인지 확인');
            } else {
                logCommand('   ✅ 연결 상태 정상');
            }

            logCommand('');
            logCommand('🔬 === 전체 진단 완료 ===');
        }

        // 상세 연결 테스트
        async function detailedConnectionTest() {
            try {
                logCommand('   📡 기본 통신 확인...');
                
                // 빈 명령어 전송
                await writer.write(new TextEncoder().encode('\r'));
                const response1 = await readWithQuickTimeout(1000);
                logCommand(`      응답1: "${response1}" (길이: ${response1.length})`);
                
                // 다른 명령어 시도
                await writer.write(new TextEncoder().encode('\r\n'));
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`      응답2: "${response2}" (길이: ${response2.length})`);
                
                // 프롬프트 패턴 분석
                const combinedResponse = response1 + response2;
                if (combinedResponse.includes('ch>')) {
                    logCommand('   ✅ tinySA 프롬프트 "ch>" 감지됨');
                } else if (combinedResponse.includes('>')) {
                    logCommand('   ✅ 일반 프롬프트 ">" 감지됨');
                } else if (combinedResponse.length > 0) {
                    logCommand('   ⚠️ 응답은 있지만 프롬프트 패턴 불일치');
                    logCommand(`      수신 데이터 분석: "${combinedResponse}"`);
                } else {
                    logCommand('   ❌ 응답 없음 - 보드레이트 또는 케이블 문제 가능성');
                }
                
                // ASCII 코드 분석
                if (combinedResponse.length > 0) {
                    const asciiCodes = Array.from(combinedResponse).map(char => char.charCodeAt(0));
                    logCommand(`      ASCII 코드: [${asciiCodes.join(', ')}]`);
                }
                
            } catch (error) {
                logCommand(`   ❌ 통신 테스트 오류: ${error.message}`);
            }
        }

        // 원시 데이터 모니터
        async function monitorRawData() {
            if (!isConnected || !reader) {
                alert('먼저 장비를 연결해주세요.');
                return;
            }

            logCommand('📡 === 원시 데이터 모니터 시작 ===');
            logCommand('⏹️ 모니터 중지: 페이지 새로고침 또는 연결 해제');
            logCommand('');

            let monitorCount = 0;
            const maxMonitorTime = 30000; // 30초
            const startTime = Date.now();

            try {
                while (isConnected && (Date.now() - startTime) < maxMonitorTime) {
                    // 주기적으로 간단한 명령어 전송
                    if (monitorCount % 5 === 0) {
                        await writer.write(new TextEncoder().encode('\r'));
                        logCommand(`[${monitorCount}] 명령 전송: "\\r"`);
                    }

                    // 데이터 읽기 시도
                    try {
                        const readPromise = reader.read();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('timeout')), 1000)
                        );
                        
                        const { value, done } = await Promise.race([readPromise, timeoutPromise]);
                        
                        if (done) {
                            logCommand('[Monitor] Reader 종료됨');
                            break;
                        }

                        if (value && value.length > 0) {
                            const text = new TextDecoder().decode(value);
                            const asciiCodes = Array.from(value).join(' ');
                            logCommand(`[${monitorCount}] 수신: "${text}" | Bytes: [${asciiCodes}]`);
                        }
                        
                    } catch (error) {
                        if (error.message !== 'timeout') {
                            logCommand(`[${monitorCount}] 읽기 오류: ${error.message}`);
                        }
                    }

                    monitorCount++;
                    await sleep(200);
                }

            } catch (error) {
                logCommand(`📡 모니터 오류: ${error.message}`);
            }

            logCommand('');
            logCommand('📡 === 원시 데이터 모니터 종료 ===');
        }

        // tinySA 장비 연결 (개선된 오류 처리)
        async function connectDevice() {
            const deviceMode = document.getElementById('deviceMode').value;
            
            if (deviceMode === 'simulation') {
                updateConnectionStatus('connected', '시뮬레이션 모드로 연결됨');
                return;
            }

            if (!('serial' in navigator)) {
                alert('이 브라우저는 Web Serial API를 지원하지 않습니다. Chrome 기반 브라우저를 사용해주세요.');
                return;
            }

            try {
                updateConnectionStatus('connecting', '1단계: 포트 선택 중...');
                
                // 시리얼 포트 요청 (개선된 오류 처리)
                logCommand('🔍 시리얼 포트 요청 중...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    // 특정 오류 메시지 분석
                    if (portError.message.includes('blocklist') || portError.message.includes('blocked')) {
                        logCommand('❌ 포트 선택 실패: 브라우저가 장치를 차단했습니다');
                        logCommand('🔍 감지된 문제: USB 장치가 시리얼 포트로 인식되지 않음');
                        logCommand('');
                        logCommand('💡 이 문제는 다음 중 하나일 수 있습니다:');
                        logCommand('   • tinySA가 USB로 제대로 연결되지 않음');
                        logCommand('   • USB 케이블이 충전 전용 (데이터 전송 불가)');
                        logCommand('   • 시스템에서 tinySA를 인식하지 못함');
                        logCommand('   • USB 드라이버 문제');
                        logCommand('');
                        logCommand('🔧 해결 방법:');
                        logCommand('   1. "USB 장치 확인" 버튼으로 시스템 상태 점검');
                        logCommand('   2. "포트 문제 해결" 버튼으로 상세 가이드 확인');
                        logCommand('   3. USB 케이블을 데이터 전송용으로 교체');
                        logCommand('   4. 장치 관리자에서 COM 포트 확인');
                        
                        updateConnectionStatus('disconnected', '포트 선택 실패 - USB 장치 문제');
                        return;
                    } else if (portError.message.includes('No port selected')) {
                        logCommand('⚠️ 사용자가 포트 선택을 취소했습니다');
                        updateConnectionStatus('disconnected', '포트 선택 취소됨');
                        return;
                    } else {
                        logCommand(`❌ 포트 선택 오류: ${portError.message}`);
                        updateConnectionStatus('disconnected', `포트 선택 실패: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`✅ 포트 선택됨: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                // tinySA 장치 식별
                if (portInfo.usbVendorId === 0x0483 && portInfo.usbProductId === 0x5740) {
                    logCommand('🎯 tinySA 장치 확인됨! (VID=0x0483, PID=0x5740)');
                } else if (portInfo.usbVendorId === 0x0483) {
                    logCommand('⚠️ STM32 기반 장치 감지됨 (tinySA 가능성 높음)');
                } else {
                    logCommand('❓ 알 수 없는 장치입니다. 계속 진행합니다...');
                }

                const selectedBaudRate = document.getElementById('baudRate').value;
                let connectConfigs = [];

                if (selectedBaudRate === 'auto') {
                    // 자동 감지: 9600부터 시작 (시스템 기본값 우선)
                    connectConfigs = [
                        { baudRate: 9600, name: '시스템 기본 (9600)' },
                        { baudRate: 115200, name: 'tinySA 표준 (115200)' },
                        { baudRate: 19200, name: '저속 안정 (19200)' },
                        { baudRate: 38400, name: '중간 속도 (38400)' },
                        { baudRate: 57600, name: 'tinySA 호환 (57600)' },
                        { baudRate: 230400, name: '고속 (230400)' }
                    ];
                } else {
                    // 사용자 선택 보드레이트 우선 시도
                    const userBaudRate = parseInt(selectedBaudRate);
                    connectConfigs = [
                        { baudRate: userBaudRate, name: `사용자 선택 (${userBaudRate})` }
                    ];
                    
                    // 실패 시 다른 보드레이트도 시도
                    const backupRates = [9600, 115200, 19200, 38400, 57600, 230400]
                        .filter(rate => rate !== userBaudRate);
                    
                    backupRates.forEach(rate => {
                        connectConfigs.push({ baudRate: rate, name: `백업 시도 (${rate})` });
                    });
                }

                logCommand(`🔧 보드레이트 설정: ${selectedBaudRate === 'auto' ? '자동 감지' : selectedBaudRate + ' bps'}`);

                for (let i = 0; i < connectConfigs.length; i++) {
                    const config = connectConfigs[i];
                    
                    try {
                        updateConnectionStatus('connecting', `${i+2}단계: ${config.name} 연결 중...`);
                        logCommand(`🔄 ${config.name} 연결 시도...`);
                        
                        // 이전 연결이 있다면 정리
                        await cleanupConnection();
                        
                        // 포트 열기
                        await serialPort.open({ 
                            baudRate: config.baudRate,
                            dataBits: 8,
                            stopBits: 1,
                            parity: 'none',
                            flowControl: 'none',
                            bufferSize: 255
                        });

                        logCommand(`📡 포트 열림 성공 (${config.baudRate} bps)`);
                        logCommand(`   • 데이터 비트: 8, 정지 비트: 1, 패리티: 없음`);
                        logCommand(`   • 흐름 제어: 없음, 버퍼 크기: 255`);

                        // Reader와 Writer 설정
                        reader = serialPort.readable.getReader();
                        writer = serialPort.writable.getWriter();
                        logCommand(`   • Reader/Writer 설정 완료`);

                        // 연결 안정화 대기
                        logCommand(`   • 연결 안정화 대기 중... (300ms)`);
                        await sleep(300);

                        // 간단한 연결 테스트
                        updateConnectionStatus('connecting', `${i+2}단계: 통신 테스트 (${config.baudRate} bps)`);
                        const testResult = await quickConnectionTest();
                        
                        if (testResult) {
                            logCommand(`✅ 연결 성공! ${config.name}`);
                            updateConnectionStatus('connected', `tinySA 연결 완료 (${config.baudRate} bps)`);
                            
                            // 기본 초기화
                            await basicInitialize();
                            
                            // 성공한 보드레이트를 UI에 반영
                            if (selectedBaudRate === 'auto') {
                                document.getElementById('baudRate').value = config.baudRate.toString();
                                logCommand(`💡 자동 감지 완료: ${config.baudRate} bps로 설정됨`);
                            }
                            
                            return;
                        } else {
                            logCommand(`❌ 통신 실패 (${config.baudRate} bps)`);
                        }

                    } catch (error) {
                        logCommand(`❌ ${config.name} 연결 실패: ${error.message}`);
                        await cleanupConnection();
                    }
                    
                    // 사용자 선택 보드레이트가 실패했고 백업 시도인 경우 짧은 지연
                    if (i === 0 && selectedBaudRate !== 'auto') {
                        logCommand(`⏳ 사용자 선택 보드레이트 실패, 백업 보드레이트로 시도...`);
                        await sleep(500);
                    }
                }

                throw new Error('모든 보드레이트에서 연결 실패 - 장비와 케이블을 확인하세요');
                
            } catch (error) {
                updateConnectionStatus('disconnected', `연결 실패: ${error.message}`);
                logCommand(`🚨 최종 연결 실패: ${error.message}`);
                
                // 연결 실패 체크리스트 제공
                logCommand('');
                logCommand('🔧 === 연결 실패 체크리스트 ===');
                logCommand('다음 항목들을 순서대로 확인해보세요:');
                logCommand('');
                logCommand('1️⃣ USB 연결 상태:');
                logCommand('   □ 데이터 전송용 케이블인가? (충전 전용 ❌)');
                logCommand('   □ 케이블을 다른 것으로 교체해봤는가?');
                logCommand('   □ USB 허브 없이 직접 연결했는가?');
                logCommand('   □ USB 2.0 포트를 사용했는가?');
                logCommand('');
                logCommand('2️⃣ tinySA 장비 상태:');
                logCommand('   □ 전원이 켜져 있고 화면이 정상인가?');
                logCommand('   □ 장비를 껐다가 다시 켜봤는가?');
                logCommand('   □ USB 포트에 이물질이 없는가?');
                logCommand('');
                logCommand('3️⃣ 시스템 인식 확인:');
                logCommand('   □ 장치 관리자에서 COM 포트가 보이는가?');
                logCommand('   □ "USB 장치 확인" 버튼으로 점검했는가?');
                logCommand('   □ 다른 프로그램에서 같은 포트를 사용 중이지 않은가?');
                logCommand('');
                logCommand('4️⃣ 즉시 해결 단계:');
                logCommand('   1. "USB 장치 확인" 클릭');
                logCommand('   2. "포트 문제 해결" 클릭');
                logCommand('   3. USB 케이블 교체 후 재시도');
                logCommand('   4. 컴퓨터 재부팅 후 재시도');
                
                await cleanupConnection();
            }
        }

        // 연결 정리
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Reader 정리 중 오류: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Writer 정리 중 오류: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`포트 닫기 중 오류: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`정리 과정 오류: ${error.message}`);
            }
        }

        // 빠른 연결 테스트
        async function quickConnectionTest() {
            try {
                logCommand('🔄 통신 테스트 시작...');
                
                // 버퍼 정리
                await sleep(100);
                
                // 1차 테스트: 간단한 엔터 전송
                logCommand('   📤 1차 테스트: CR 전송');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response1 = await readWithQuickTimeout(1500);
                logCommand(`   📥 1차 응답: "${response1}" (길이: ${response1.length})`);
                
                if (response1.length > 0) {
                    const asciiCodes = Array.from(response1).map(c => c.charCodeAt(0)).join(' ');
                    logCommand(`   🔢 ASCII 코드: [${asciiCodes}]`);
                }
                
                // 2차 테스트: CRLF 전송
                logCommand('   📤 2차 테스트: CRLF 전송');
                await writer.write(new TextEncoder().encode('\r\n'));
                
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`   📥 2차 응답: "${response2}" (길이: ${response2.length})`);
                
                // 응답 분석
                const combinedResponse = response1 + response2;
                logCommand(`   🔍 종합 분석: "${combinedResponse}"`);
                
                // tinySA 프롬프트 패턴 확인
                if (combinedResponse.includes('ch>') || 
                    combinedResponse.includes('Ch>') || 
                    combinedResponse.includes('CH>')) {
                    logCommand('   ✅ tinySA 프롬프트 "ch>" 확인됨');
                    return true;
                } else if (combinedResponse.includes('>')) {
                    logCommand('   ✅ 일반 프롬프트 ">" 확인됨 (tinySA 가능성 높음)');
                    return true;
                } else if (combinedResponse.length > 0) {
                    logCommand('   ⚠️ 응답은 있지만 프롬프트 형식 다름');
                    logCommand('   💡 장비가 다른 모드에 있거나 다른 기기일 수 있음');
                    
                    // 그래도 통신은 되므로 연결 시도
                    if (combinedResponse.length > 3) {
                        logCommand('   🔄 응답이 충분하므로 연결 시도함');
                        return true;
                    }
                    return false;
                } else {
                    logCommand('   ❌ 응답 없음');
                    logCommand('   🔧 가능한 원인:');
                    logCommand('      • 보드레이트 불일치');
                    logCommand('      • 케이블 불량 (충전 전용)');
                    logCommand('      • 장비 전원 꺼짐');
                    logCommand('      • 다른 프로그램에서 포트 사용 중');
                    return false;
                }
                
            } catch (error) {
                logCommand(`❌ 연결 테스트 실패: ${error.message}`);
                logCommand('🔧 세부 오류 정보:');
                logCommand(`   • 오류 타입: ${error.constructor.name}`);
                logCommand(`   • 오류 스택: ${error.stack?.split('\n')[0] || '정보 없음'}`);
                return false;
            }
        }

        // 빠른 타임아웃 읽기
        async function readWithQuickTimeout(timeoutMs) {
            return new Promise(async (resolve, reject) => {
                let response = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(response); // 타임아웃 시에도 기존 응답 반환
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 500))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        // 충분한 응답이 왔으면 조기 종료
                        if (response.length > 10 || response.includes('>')) {
                            break;
                        }
                    }
                } catch (error) {
                    // 읽기 오류는 무시하고 기존 응답 반환
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                    resolve(response);
                }
            });
        }

        // 기본 초기화
        async function basicInitialize() {
            try {
                logCommand('🔧 기본 초기화 시작...');
                
                // 안전한 기본 명령어들
                await sleep(200);
                await safeCommand('resume', 1000);
                await sleep(200);
                
                logCommand('✅ 기본 초기화 완료');
                
            } catch (error) {
                logCommand(`⚠️ 초기화 경고: ${error.message} (정상 동작 가능)`);
            }
        }

        // 안전한 명령어 전송
        async function safeCommand(command, timeoutMs = 2000) {
            try {
                logCommand(`📤 명령: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                const response = await readWithQuickTimeout(timeoutMs);
                logCommand(`📥 응답: "${response}"`);
                
                return response;
            } catch (error) {
                logCommand(`⚠️ 명령 "${command}" 오류: ${error.message}`);
                return null;
            }
        }

        // 장비 연결 해제
        async function disconnectDevice() {
            try {
                if (reader) {
                    await reader.cancel();
                    await reader.releaseLock();
                    reader = null;
                }
                
                if (writer) {
                    await writer.releaseLock();
                    writer = null;
                }
                
                if (serialPort) {
                    await serialPort.close();
                    serialPort = null;
                }
                
                updateConnectionStatus('disconnected', '장비 연결 해제됨');
                
            } catch (error) {
                logCommand(`연결 해제 오류: ${error.message}`);
                console.error('Disconnect error:', error);
            }
        }

        // 명령어 전송
        async function sendCommand(command) {
            if (!isConnected) {
                logCommand(`시뮬레이션: ${command}`);
                return 'OK';
            }

            try {
                logCommand(`전송: ${command}`);
                
                // 명령어 전송 (\r만 사용 - tinySA 표준)
                const data = new TextEncoder().encode(command + '\r');
                await writer.write(data);
                
                // 응답 읽기
                const response = await readResponseWithTimeout(5000);
                logCommand(`응답: "${response}"`);
                
                return response;
                
            } catch (error) {
                logCommand(`명령어 오류: ${error.message}`);
                throw error;
            }
        }

        // 타임아웃이 있는 응답 읽기
        async function readResponseWithTimeout(timeoutMs = 5000) {
            return new Promise(async (resolve, reject) => {
                let response = '';
                let timeoutId;
                
                const timeout = setTimeout(() => {
                    reject(new Error('응답 시간 초과'));
                }, timeoutMs);
                
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        // 다양한 프롬프트 패턴 확인
                        if (response.includes('ch>') || 
                            response.includes('Ch>') || 
                            response.includes('CH>') ||
                            response.endsWith('> ') ||
                            response.endsWith('>')) {
                            break;
                        }
                        
                        // 너무 긴 응답 방지
                        if (response.length > 10000) {
                            break;
                        }
                    }
                    
                    clearTimeout(timeout);
                    
                    // 프롬프트 제거 및 정리
                    const cleaned = response
                        .replace(/ch>/gi, '')
                        .replace(/>/g, '')
                        .replace(/\r/g, '')
                        .trim();
                        
                    resolve(cleaned);
                    
                } catch (error) {
                    clearTimeout(timeout);
                    reject(error);
                }
            });
        }

        // 응답 읽기 (레거시 - 호환성용)
        async function readResponse() {
            return await readResponseWithTimeout(5000);
        }

        // 실제 장비에서 스펙트럼 데이터 가져오기
        async function getHardwareSpectrum() {
            try {
                const startFreq = parseFloat(document.getElementById('startFreq').value) * 1e6; // MHz to Hz
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) * 1e6;
                const points = parseInt(document.getElementById('scanPoints').value);

                logCommand('하드웨어 스펙트럼 측정 시작...');

                // 스위프 설정
                await sendCommandSafe(`sweep start ${Math.floor(startFreq)}`);
                await sleep(200);
                await sendCommandSafe(`sweep stop ${Math.floor(stopFreq)}`);
                await sleep(200);

                // 스캔 포인트 설정 (tinySA는 자동으로 조정될 수 있음)
                logCommand(`주파수 범위: ${startFreq/1e6} - ${stopFreq/1e6} MHz`);

                // 스캔 실행 및 완료 대기
                await sendCommandSafe('resume');
                await sleep(1000); // 스캔 완료 대기

                // 주파수 정보 가져오기
                const freqResponse = await sendCommandSafe('frequencies');
                if (!freqResponse) {
                    throw new Error('주파수 데이터를 가져올 수 없습니다');
                }

                // 스펙트럼 데이터 가져오기 (Array 0 = 신호 강도)
                const dataResponse = await sendCommandSafe('data 0');
                if (!dataResponse) {
                    throw new Error('스펙트럼 데이터를 가져올 수 없습니다');
                }

                // 데이터 파싱
                const freqLines = freqResponse.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !isNaN(parseFloat(line)));
                    
                const dataLines = dataResponse.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !isNaN(parseFloat(line)));

                logCommand(`파싱된 데이터: 주파수 ${freqLines.length}개, 신호 ${dataLines.length}개`);

                if (freqLines.length === 0 || dataLines.length === 0) {
                    throw new Error('유효한 데이터가 없습니다');
                }

                // 데이터 길이 맞추기
                const minLength = Math.min(freqLines.length, dataLines.length);
                const freqs = freqLines.slice(0, minLength).map(line => parseFloat(line) / 1e6); // Hz to MHz
                const spectrum = dataLines.slice(0, minLength).map(line => parseFloat(line));

                logCommand(`최종 데이터: ${freqs.length}개 포인트`);

                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`하드웨어 스캔 오류: ${error.message}`);
                
                // 오류 시 시뮬레이션 데이터로 대체
                logCommand('시뮬레이션 데이터로 대체합니다...');
                return simulateSpectrum();
            }
        }

        // 연결 진단 기능
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('장비가 연결되지 않았습니다');
                return;
            }

            try {
                logCommand('=== 연결 진단 시작 ===');
                
                // 1. 기본 통신 테스트
                logCommand('1. 기본 통신 테스트...');
                await writer.write(new TextEncoder().encode('\r'));
                const basicResponse = await readResponseWithTimeout(2000);
                logCommand(`기본 응답: "${basicResponse}"`);

                // 2. 버전 정보
                logCommand('2. 버전 정보 확인...');
                const version = await sendCommandSafe('version');
                logCommand(`버전: ${version || '정보 없음'}`);

                // 3. 현재 상태
                logCommand('3. 현재 상태 확인...');
                const freqs = await sendCommandSafe('frequencies');
                if (freqs) {
                    const freqCount = freqs.split('\n').filter(line => line.trim()).length;
                    logCommand(`현재 주파수 포인트: ${freqCount}개`);
                }

                // 4. 간단한 데이터 테스트
                logCommand('4. 데이터 테스트...');
                const testData = await sendCommandSafe('data 0');
                if (testData) {
                    const dataCount = testData.split('\n').filter(line => line.trim()).length;
                    logCommand(`데이터 포인트: ${dataCount}개`);
                }

                logCommand('=== 진단 완료 ===');
                
            } catch (error) {
                logCommand(`진단 오류: ${error.message}`);
            }
        }

        // 차트 초기화
        function initChart() {
            const ctx = document.getElementById('spectrumChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: '신호 강도 (dBm)',
                        data: [],
                        borderColor: '#4a6cf7',
                        backgroundColor: 'rgba(74, 108, 247, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.2,
                        pointRadius: 0,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '주파수 (MHz)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: '신호 강도 (dBm)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const elementIndex = elements[0].index;
                            const frequency = frequencies[elementIndex];
                            const amplitude = spectrumData[elementIndex];
                            updateMarker(frequency, amplitude);
                        }
                    },
                    animation: {
                        duration: 500
                    }
                }
            });
        }

        // 주파수 배열 생성
        function generateFrequencies(start, stop, points) {
            const step = (stop - start) / (points - 1);
            const freqs = [];
            for (let i = 0; i < points; i++) {
                freqs.push(start + i * step);
            }
            return freqs;
        }

        // 스펙트럼 데이터 시뮬레이션
        function simulateSpectrum() {
            const startFreq = parseFloat(document.getElementById('startFreq').value);
            const stopFreq = parseFloat(document.getElementById('stopFreq').value);
            const points = parseInt(document.getElementById('scanPoints').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);

            // 신호 파라미터 읽기
            const signal1Freq = parseFloat(document.getElementById('signal1Freq').value);
            const signal1Amp = parseFloat(document.getElementById('signal1Amp').value);
            const signal1Type = document.getElementById('signal1Type').value;

            const signal2Freq = parseFloat(document.getElementById('signal2Freq').value);
            const signal2Amp = parseFloat(document.getElementById('signal2Amp').value);
            const signal2Type = document.getElementById('signal2Type').value;

            frequencies = generateFrequencies(startFreq, stopFreq, points);
            spectrumData = [];

            for (let i = 0; i < frequencies.length; i++) {
                const freq = frequencies[i];
                let amplitude = noiseLevel + (Math.random() - 0.5) * 10;

                // 신호 1 추가
                if (signal1Freq >= startFreq && signal1Freq <= stopFreq) {
                    const signal1Component = calculateSignalComponent(freq, signal1Freq, signal1Amp, signal1Type);
                    amplitude = combineSignals(amplitude, signal1Component);
                }

                // 신호 2 추가
                if (signal2Freq >= startFreq && signal2Freq <= stopFreq) {
                    const signal2Component = calculateSignalComponent(freq, signal2Freq, signal2Amp, signal2Type);
                    amplitude = combineSignals(amplitude, signal2Component);
                }

                spectrumData.push(amplitude);
            }

            return { frequencies, spectrum: spectrumData };
        }

        // 신호 컴포넌트 계산
        function calculateSignalComponent(currentFreq, signalFreq, signalAmp, signalType) {
            const freqDiff = Math.abs(currentFreq - signalFreq);
            let component = -100; // 기본 낮은 값

            switch (signalType) {
                case 'sine':
                    if (freqDiff < 5) {
                        component = signalAmp - (freqDiff * freqDiff * 2);
                    }
                    break;
                case 'square':
                    if (freqDiff < 5) {
                        component = signalAmp - (freqDiff * freqDiff * 1.5);
                    }
                    // 고조파 추가
                    for (let harmonic = 3; harmonic <= 9; harmonic += 2) {
                        const harmonicFreq = signalFreq * harmonic;
                        const harmonicDiff = Math.abs(currentFreq - harmonicFreq);
                        if (harmonicDiff < 2) {
                            const harmonicAmp = signalAmp - 20 * Math.log10(harmonic) - harmonicDiff * 10;
                            component = combineSignals(component, harmonicAmp);
                        }
                    }
                    break;
                case 'noise':
                    component = signalAmp + (Math.random() - 0.5) * 20;
                    break;
            }

            return component;
        }

        // 신호 결합 (dB 스케일)
        function combineSignals(signal1_dB, signal2_dB) {
            const power1 = Math.pow(10, signal1_dB / 10);
            const power2 = Math.pow(10, signal2_dB / 10);
            const totalPower = power1 + power2;
            return 10 * Math.log10(totalPower);
        }

        // 스캔 시작
        async function startScan() {
            if (isScanning) return;
            
            isScanning = true;
            document.getElementById('statusDisplay').textContent = '스캔 중...';
            
            try {
                const deviceMode = document.getElementById('deviceMode').value;
                let data;

                if (deviceMode === 'hardware' && isConnected) {
                    // 실제 하드웨어에서 데이터 가져오기
                    logCommand('하드웨어 스캔 시작...');
                    data = await getHardwareSpectrum();
                } else {
                    // 시뮬레이션 데이터 생성
                    logCommand('시뮬레이션 스캔 시작...');
                    
                    // 온도 시뮬레이션 업데이트
                    const temp = 25 + (Math.random() - 0.5) * 10;
                    document.getElementById('temperature').value = temp.toFixed(1);
                    
                    await new Promise(resolve => setTimeout(resolve, 1000)); // 시뮬레이션 지연
                    data = simulateSpectrum();
                }
                
                // 차트 업데이트
                frequencies = data.frequencies;
                spectrumData = data.spectrum;
                
                chart.data.labels = data.frequencies.map(f => f.toFixed(1));
                chart.data.datasets[0].data = data.spectrum;
                chart.update();

                document.getElementById('statusDisplay').textContent = 
                    `스캔 완료 - ${data.frequencies.length}개 포인트, 범위: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                
                logCommand('스캔 완료');
                
            } catch (error) {
                document.getElementById('statusDisplay').textContent = `스캔 오류: ${error.message}`;
                logCommand(`스캔 오류: ${error.message}`);
            } finally {
                isScanning = false;
            }
        }

        // 마커 업데이트
        function updateMarker(frequency, amplitude) {
            document.getElementById('markerInfo').innerHTML = `
                <strong>주파수:</strong> ${frequency.toFixed(2)} MHz<br>
                <strong>진폭:</strong> ${amplitude.toFixed(1)} dBm
            `;
        }

        // CSV 다운로드
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('먼저 스캔을 실행해주세요.');
                return;
            }

            let csvContent = "주파수(MHz),신호강도(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // 고급 설정 적용
        async function applyAdvancedSettings() {
            try {
                const outputLevel = document.getElementById('outputLevel').value;
                const outputMode = document.getElementById('outputMode').value;
                const inputMode = document.getElementById('inputMode').value;
                const rbw = document.getElementById('rbw').value;

                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    // 실제 하드웨어 설정
                    await sendCommand(`level ${outputLevel}`);
                    await sendCommand(`output ${outputMode}`);
                    await sendCommand(`mode ${inputMode} input`);
                    
                    if (rbw === 'auto') {
                        await sendCommand('rbw auto');
                    } else {
                        await sendCommand(`rbw ${rbw}`);
                    }
                    
                    logCommand('하드웨어 설정 적용 완료');
                } else {
                    // 시뮬레이션 모드
                    logCommand(`시뮬레이션: 출력 레벨 ${outputLevel}dBm, 출력 ${outputMode}, 입력 모드 ${inputMode}`);
                }
                
                document.getElementById('statusDisplay').textContent = '고급 설정이 적용되었습니다';
                
            } catch (error) {
                logCommand(`설정 적용 오류: ${error.message}`);
            }
        }

        // 온도 측정
        async function getTemperature() {
            try {
                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    // 실제 하드웨어에서 온도 읽기
                    const response = await sendCommand('k'); // 온도 명령어
                    const temp = parseFloat(response);
                    if (!isNaN(temp)) {
                        document.getElementById('temperature').value = temp.toFixed(1);
                        logCommand(`하드웨어 온도: ${temp.toFixed(1)}°C`);
                    }
                } else {
                    // 시뮬레이션 온도
                    const temp = 25 + (Math.random() - 0.5) * 15;
                    document.getElementById('temperature').value = temp.toFixed(1);
                    logCommand(`시뮬레이션 온도: ${temp.toFixed(1)}°C`);
                }
            } catch (error) {
                logCommand(`온도 측정 오류: ${error.message}`);
            }
        }

        // 페이지 로드 시 초기화
        window.addEventListener('load', function() {
            initChart();
            
            // 브라우저 콘솔에 디버깅 정보 출력
            console.log('=== tinySA 스펙트럼 분석기 디버깅 모드 ===');
            console.log('UI 로그 외에 콘솔에서도 상세 정보를 확인할 수 있습니다.');
            console.log('연결 문제 발생 시 이 콘솔 내용을 참고하세요.');
            console.log('');
            
            // 브라우저 지원 확인
            if (!('serial' in navigator)) {
                document.getElementById('deviceMode').innerHTML = '<option value="simulation">시뮬레이션 모드 (Web Serial API 미지원)</option>';
                logCommand('❌ 경고: 이 브라우저는 Web Serial API를 지원하지 않습니다.');
                logCommand('🔧 해결방법: Chrome, Edge, Opera 등의 브라우저를 사용하세요.');
                logCommand('📋 Chrome 버전 89 이상이 필요합니다.');
                
                console.error('Web Serial API not supported. Browser:', navigator.userAgent);
            } else {
                logCommand('✅ Web Serial API 지원됨');
                logCommand('');
                logCommand('📌 === tinySA 연결 가이드 ===');
                logCommand('1️⃣ Windows 장치 관리자에서 COM 포트의 비트/초 확인');
                logCommand('2️⃣ 확인된 보드레이트를 위 "보드레이트" 메뉴에서 선택');
                logCommand('   • 9600 bps: 가장 일반적인 시스템 기본값');
                logCommand('   • 115200 bps: tinySA 공장 기본값');
                logCommand('   • 자동 감지: 확실하지 않을 때 권장');
                logCommand('3️⃣ tinySA를 데이터 전송용 USB 케이블로 PC에 연결');
                logCommand('4️⃣ tinySA 전원이 켜져 있고 정상 화면이 표시되는지 확인');
                logCommand('5️⃣ "장비 모드"를 "실제 장비 연결"로 선택');
                logCommand('6️⃣ "장비 연결" 버튼 클릭');
                logCommand('7️⃣ 팝업에서 적절한 포트 선택 (보통 "USB Serial Device")');
                logCommand('8️⃣ 연결 완료 후 "연결 진단"으로 상태 확인');
                logCommand('');
                logCommand('💡 보드레이트가 맞지 않으면 연결 실패!');
                logCommand('🚨 연결 실패 시: "전체 진단" 및 "원시 데이터 모니터" 활용');
                logCommand('🔧 고급 디버깅: F12 → Console 탭에서 상세 오류 확인');
                
                console.log('Web Serial API supported. Ready for tinySA connection.');
            }
            
            // 연결 해제 감지
            if ('serial' in navigator) {
                navigator.serial.addEventListener('disconnect', (event) => {
                    if (event.target === serialPort) {
                        updateConnectionStatus('disconnected', '🔌 장비 연결이 해제되었습니다 (USB 케이블 확인)');
                        console.warn('tinySA disconnected unexpectedly');
                        serialPort = null;
                        reader = null;
                        writer = null;
                    }
                });
                
                // 기존 허용된 포트 확인
                navigator.serial.getPorts().then(ports => {
                    if (ports.length > 0) {
                        logCommand(`💡 기존 허용된 포트 ${ports.length}개 발견됨`);
                        console.log('Previously authorized ports:', ports);
                    }
                }).catch(err => {
                    console.error('Error checking existing ports:', err);
                });
            }
            
            // 자동 스캔 (초기 데이터)
            setTimeout(() => {
                startScan();
            }, 500);
            
            logCommand('🚀 시스템 초기화 완료');
            console.log('tinySA Simulator initialized successfully');
        });

        // 실시간 업데이트 (옵션)
        setInterval(() => {
            if (!isScanning) {
                // 온도 변화 시뮬레이션
                const currentTemp = parseFloat(document.getElementById('temperature').value);
                const newTemp = currentTemp + (Math.random() - 0.5) * 0.5;
                document.getElementById('temperature').value = newTemp.toFixed(1);
            }
        }, 5000);
    </script>
</body>
</html>
