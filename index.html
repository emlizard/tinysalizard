<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinySA Spectrum Analyzer & Signal Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            border-radius: 15px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            min-width: 200px;
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 108, 247, 0.4);
        }

        .mode-btn.inactive {
            background: #f0f0f0;
            color: #666;
        }

        .mode-btn.inactive:hover {
            background: #e0e0e0;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e1e8ff;
        }

        .mode-section {
            display: none;
        }

        .mode-section.active {
            display: block;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4a5568;
            font-size: 14px;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ff;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #4a6cf7;
            box-shadow: 0 0 0 3px rgba(74, 108, 247, 0.1);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4a6cf7, #667eea);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(74, 108, 247, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(72, 187, 120, 0.4);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(237, 137, 54, 0.4);
        }

        .chart-container {
            background: #ffffff;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e1e8ff;
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
        }

        .signal-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .signal-group {
            background: #f0f7ff;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #bee3f8;
        }

        .signal-group h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .marker-info {
            background: linear-gradient(45deg, #ffd89b, #19547b);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .marker-info h3 {
            margin-bottom: 10px;
        }

        .status-bar {
            background: #2d3748;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            align-items: end;
        }

        .unit-label {
            background: #e1e8ff;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            color: #4a5568;
            display: flex;
            align-items: center;
        }

        .status-indicator {
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

        .status-indicator.connected {
            background: linear-gradient(45deg, #48bb78, #38a169);
            color: white;
        }

        .status-indicator.disconnected {
            background: linear-gradient(45deg, #f56565, #e53e3e);
            color: white;
        }

        .status-indicator.connecting {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .command-log {
            background: #2d3748;
            color: #68d391;
            font-family: monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            margin-top: 15px;
            border: 2px solid #4a5568;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .signal-gen-panel {
            background: #fff5f5;
            border: 2px solid #fed7d7;
        }

        .signal-gen-panel h3 {
            color: #c53030;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .signal-controls {
                grid-template-columns: 1fr;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }

            .mode-selector {
                flex-direction: column;
                align-items: center;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ TinySA Spectrum Analyzer & Signal Generator</h1>
            <p>RF Signal Analysis and Generation Tool</p>
        </div>

        <!-- Mode Selection -->
        <div class="mode-selector">
            <button class="mode-btn active" onclick="switchMode('analyzer')" id="analyzerModeBtn">
                üìä Spectrum Analyzer
            </button>
            <button class="mode-btn inactive" onclick="switchMode('generator')" id="generatorModeBtn">
                üì° Signal Generator
            </button>
        </div>

        <div class="controls-grid">
            <div class="control-panel">
                <h2>üîå Device Connection</h2>
                
                <div class="control-group">
                    <label>Connection Status</label>
                    <div id="connectionStatus" class="status-indicator disconnected">Disconnected</div>
                </div>

                <div class="control-group">
                    <label>Device Mode</label>
                    <select id="deviceMode">
                        <option value="simulation">Simulation Mode</option>
                        <option value="hardware">Hardware Connection</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Baud Rate (bps)</label>
                    <select id="baudRate">
                        <option value="auto">Auto Detect (Recommended)</option>
                        <option value="9600" selected>9600 (System Default)</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200">115200 (tinySA Standard)</option>
                        <option value="230400">230400</option>
                    </select>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" id="connectBtn" onclick="connectDevice()">üîå Connect</button>
                    <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnectDevice()" disabled>‚ùå Disconnect</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="diagnoseConnection()" id="diagnoseBtn" disabled>üîç Diagnose</button>
                    <button class="btn btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
                </div>

                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn btn-secondary" onclick="debugChart()" id="chartDebugBtn">üìà Debug Chart</button>
                    <button class="btn btn-secondary" onclick="testDataGeneration()">üß™ Test Data</button>
                </div>

                <hr style="margin: 20px 0; border: 1px solid #e1e8ff;">

                <!-- Spectrum Analyzer Controls -->
                <div id="analyzerControls" class="mode-section active">
                    <h2>üì° Frequency Settings</h2>
                    
                    <div class="control-group">
                        <label>Start Frequency</label>
                        <div class="input-group">
                            <input type="number" id="startFreq" value="1" step="0.1">
                            <span class="unit-label">MHz</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Stop Frequency</label>
                        <div class="input-group">
                            <input type="number" id="stopFreq" value="900" step="0.1">
                            <span class="unit-label">MHz</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Scan Points</label>
                        <select id="scanPoints">
                            <option value="101">101</option>
                            <option value="201">201</option>
                            <option value="301">301</option>
                            <option value="501">501</option>
                            <option value="801">801</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>RBW (Resolution Bandwidth)</label>
                        <select id="rbw">
                            <option value="auto">Auto</option>
                            <option value="1">1 kHz</option>
                            <option value="3">3 kHz</option>
                            <option value="10">10 kHz</option>
                            <option value="30">30 kHz</option>
                            <option value="100">100 kHz</option>
                        </select>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-primary" onclick="startScan()">üîç Start Scan</button>
                        <button class="btn btn-secondary" onclick="downloadCSV()">üíæ Save CSV</button>
                    </div>

                    <div class="marker-info">
                        <h3>üìç Marker Information</h3>
                        <div id="markerInfo">Click on chart to set marker</div>
                    </div>
                </div>

                <!-- Signal Generator Controls -->
                <div id="generatorControls" class="mode-section">
                    <h2>üì° Signal Generation</h2>
                    
                    <div class="control-group">
                        <label>Output Frequency</label>
                        <div class="input-group">
                            <input type="number" id="genFreq" value="100" step="0.1">
                            <span class="unit-label">MHz</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Output Level</label>
                        <div class="input-group">
                            <input type="number" id="genLevel" value="-10" step="1">
                            <span class="unit-label">dBm</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Output Mode</label>
                        <select id="genMode">
                            <option value="off">OFF</option>
                            <option value="on">ON</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Modulation</label>
                        <select id="modulation">
                            <option value="cw">CW (Continuous Wave)</option>
                            <option value="am">AM</option>
                            <option value="fm">FM</option>
                            <option value="sweep">Frequency Sweep</option>
                        </select>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-warning" onclick="startGeneration()">üì° Start Output</button>
                        <button class="btn btn-secondary" onclick="stopGeneration()">‚èπÔ∏è Stop Output</button>
                    </div>

                    <div class="control-group">
                        <label>Sweep Settings (for Sweep Mode)</label>
                        <div class="input-group">
                            <input type="number" id="sweepStart" value="1" step="0.1" placeholder="Start MHz">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <input type="number" id="sweepStop" value="100" step="0.1" placeholder="Stop MHz">
                        </div>
                        <div class="input-group" style="margin-top: 10px;">
                            <input type="number" id="sweepTime" value="1" step="0.1" placeholder="Sweep Time (s)">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <label>Command Log</label>
                    <div id="commandLog" class="command-log">System ready...\n</div>
                </div>
            </div>

            <div class="chart-container">
                <h2 id="chartTitle">üìä Spectrum Analysis</h2>
                <div class="chart-wrapper">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Analyzer Mode Signal Controls -->
        <div id="analyzerSignalControls" class="signal-controls">
            <div class="signal-group">
                <h3>üéØ Signal 1 Settings</h3>
                <div class="control-group">
                    <label>Frequency (MHz)</label>
                    <input type="number" id="signal1Freq" value="100" step="0.1">
                </div>
                <div class="control-group">
                    <label>Amplitude (dBm)</label>
                    <input type="number" id="signal1Amp" value="-20" step="1">
                </div>
                <div class="control-group">
                    <label>Signal Type</label>
                    <select id="signal1Type">
                        <option value="sine">Sine Wave</option>
                        <option value="square">Square Wave</option>
                        <option value="noise">Noise</option>
                    </select>
                </div>
            </div>

            <div class="signal-group">
                <h3>üéØ Signal 2 Settings</h3>
                <div class="control-group">
                    <label>Frequency (MHz)</label>
                    <input type="number" id="signal2Freq" value="200" step="0.1">
                </div>
                <div class="control-group">
                    <label>Amplitude (dBm)</label>
                    <input type="number" id="signal2Amp" value="-30" step="1">
                </div>
                <div class="control-group">
                    <label>Signal Type</label>
                    <select id="signal2Type">
                        <option value="sine">Sine Wave</option>
                        <option value="square">Square Wave</option>
                        <option value="noise">Noise</option>
                    </select>
                </div>
            </div>

            <div class="signal-group">
                <h3>üîß Advanced Settings</h3>
                <div class="control-group">
                    <label>Noise Level (dBm)</label>
                    <input type="number" id="noiseLevel" value="-80" step="1">
                </div>
                <div class="control-group">
                    <label>Input Mode</label>
                    <select id="inputMode">
                        <option value="low">Low Input</option>
                        <option value="high">High Input</option>
                    </select>
                </div>
                <button class="btn btn-primary" onclick="applyAdvancedSettings()" style="width: 100%; margin-top: 10px;">‚öôÔ∏è Apply Settings</button>
            </div>

            <div class="signal-group">
                <h3>üîä Status & Temperature</h3>
                <div class="control-group">
                    <label>Temperature (¬∞C)</label>
                    <input type="number" id="temperature" value="25" step="1" readonly>
                </div>
                <button class="btn btn-secondary" onclick="getTemperature()" style="width: 100%; margin-top: 10px;">üå°Ô∏è Measure Temperature</button>
            </div>
        </div>

        <!-- Generator Mode Controls -->
        <div id="generatorSignalControls" class="signal-controls hidden">
            <div class="signal-group signal-gen-panel">
                <h3>‚ö†Ô∏è Signal Generator Status</h3>
                <div class="control-group">
                    <label>Output Status</label>
                    <div id="genStatus" class="status-indicator disconnected">Output OFF</div>
                </div>
                <div class="control-group">
                    <label>Current Frequency</label>
                    <input type="text" id="currentGenFreq" value="--" readonly>
                </div>
                <div class="control-group">
                    <label>Current Level</label>
                    <input type="text" id="currentGenLevel" value="--" readonly>
                </div>
                <button class="btn btn-warning" onclick="emergencyStop()" style="width: 100%; margin-top: 10px;">üö® Emergency Stop</button>
            </div>

            <div class="signal-group">
                <h3>üìä Output Monitoring</h3>
                <div class="control-group">
                    <label>Power Monitor</label>
                    <input type="text" id="powerMonitor" value="-- dBm" readonly>
                </div>
                <div class="control-group">
                    <label>VSWR</label>
                    <input type="text" id="vswr" value="--" readonly>
                </div>
                <button class="btn btn-secondary" onclick="updateMonitoring()" style="width: 100%; margin-top: 10px;">üìä Update Readings</button>
            </div>
        </div>

        <div class="status-bar">
            <div id="statusDisplay">System ready - Start scan or signal generation</div>
        </div>
    </div>

    <script>
        let chart;
        let spectrumData = [];
        let frequencies = [];
        let isScanning = false;
        let isGenerating = false;
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;
        let currentMode = 'analyzer'; // 'analyzer' or 'generator'

        // TinySA device identifiers
        const TINYSA_VID = 0x0483; // 1155
        const TINYSA_PID = 0x5740; // 22336

        // Mode switching
        function switchMode(mode) {
            currentMode = mode;
            
            // Update button states
            const analyzerBtn = document.getElementById('analyzerModeBtn');
            const generatorBtn = document.getElementById('generatorModeBtn');
            
            if (mode === 'analyzer') {
                analyzerBtn.className = 'mode-btn active';
                generatorBtn.className = 'mode-btn inactive';
                
                // Show analyzer controls, hide generator controls
                document.getElementById('analyzerControls').classList.add('active');
                document.getElementById('generatorControls').classList.remove('active');
                document.getElementById('analyzerSignalControls').classList.remove('hidden');
                document.getElementById('generatorSignalControls').classList.add('hidden');
                
                // Update chart title
                document.getElementById('chartTitle').textContent = 'üìä Spectrum Analysis';
                
                logCommand('üîÑ Switched to Spectrum Analyzer mode');
                
                // Stop signal generation if active
                if (isGenerating) {
                    stopGeneration();
                }
                
            } else if (mode === 'generator') {
                analyzerBtn.className = 'mode-btn inactive';
                generatorBtn.className = 'mode-btn active';
                
                // Show generator controls, hide analyzer controls
                document.getElementById('analyzerControls').classList.remove('active');
                document.getElementById('generatorControls').classList.add('active');
                document.getElementById('analyzerSignalControls').classList.add('hidden');
                document.getElementById('generatorSignalControls').classList.remove('hidden');
                
                // Update chart title
                document.getElementById('chartTitle').textContent = 'üì° Signal Generator Output';
                
                logCommand('üîÑ Switched to Signal Generator mode');
                
                // Stop scanning if active
                if (isScanning) {
                    isScanning = false;
                }
            }
        }

        // Sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Log output function
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (message.includes('‚ùå') || message.includes('Error') || message.includes('Failed')) {
                console.error('tinySA:', message);
            } else if (message.includes('‚ö†Ô∏è') || message.includes('Warning')) {
                console.warn('tinySA:', message);
            } else if (message.includes('‚úÖ') || message.includes('Success')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // Update connection status
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.textContent = 'Connected ‚úì';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    diagnoseBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.textContent = 'Disconnected';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    diagnoseBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.textContent = 'Connecting...';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = true;
                    diagnoseBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }

        // Safe command sending
        async function sendCommandSafe(command, timeoutMs = 2000) {
            try {
                logCommand(`üì§ Safe command: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                const response = await readWithQuickTimeout(timeoutMs);
                logCommand(`üì• Safe response: "${response}"`);
                
                return response;
            } catch (error) {
                logCommand(`‚ö†Ô∏è Safe command "${command}" error: ${error.message} (ignored)`);
                return null;
            }
        }

        // Send command
        async function sendCommand(command) {
            if (!isConnected) {
                logCommand(`Simulation: ${command}`);
                return 'OK';
            }

            try {
                logCommand(`Sending: ${command}`);
                
                const data = new TextEncoder().encode(command + '\r');
                await writer.write(data);
                
                const response = await readResponseWithTimeout(5000);
                logCommand(`Response: "${response}"`);
                
                return response;
                
            } catch (error) {
                logCommand(`Command error: ${error.message}`);
                throw error;
            }
        }

        // Read response with timeout
        async function readResponseWithTimeout(timeoutMs = 5000) {
            return new Promise(async (resolve, reject) => {
                let response = '';
                
                const timeout = setTimeout(() => {
                    reject(new Error('Response timeout'));
                }, timeoutMs);
                
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.includes('ch>') || 
                            response.includes('Ch>') || 
                            response.includes('CH>') ||
                            response.endsWith('> ') ||
                            response.endsWith('>')) {
                            break;
                        }
                        
                        if (response.length > 10000) {
                            break;
                        }
                    }
                    
                    clearTimeout(timeout);
                    
                    const cleaned = response
                        .replace(/ch>/gi, '')
                        .replace(/>/g, '')
                        .replace(/\r/g, '')
                        .trim();
                        
                    resolve(cleaned);
                    
                } catch (error) {
                    clearTimeout(timeout);
                    reject(error);
                }
            });
        }

        // Quick timeout read
        async function readWithQuickTimeout(timeoutMs) {
            return new Promise(async (resolve) => {
                let response = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(response);
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 500))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.length > 10 || response.includes('>')) {
                            break;
                        }
                    }
                } catch (error) {
                    // Ignore read errors
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                    resolve(response);
                }
            });
        }

        // Clean up connection
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Reader cleanup error: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`Writer cleanup error: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`Port close error: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`Cleanup error: ${error.message}`);
            }
        }

        // Connect device
        async function connectDevice() {
            const deviceMode = document.getElementById('deviceMode').value;
            
            if (deviceMode === 'simulation') {
                updateConnectionStatus('connected', 'Connected in simulation mode');
                return;
            }

            if (!('serial' in navigator)) {
                alert('This browser does not support Web Serial API. Please use Chrome-based browser.');
                return;
            }

            try {
                updateConnectionStatus('connecting', 'Step 1: Selecting port...');
                
                logCommand('üîç Requesting serial port...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    if (portError.message.includes('blocklist') || portError.message.includes('blocked')) {
                        logCommand('‚ùå Port selection failed: Browser blocked the device');
                        logCommand('üîç Detected issue: USB device not recognized as serial port');
                        updateConnectionStatus('disconnected', 'Port selection failed - USB device issue');
                        return;
                    } else if (portError.message.includes('No port selected')) {
                        logCommand('‚ö†Ô∏è User cancelled port selection');
                        updateConnectionStatus('disconnected', 'Port selection cancelled');
                        return;
                    } else {
                        logCommand(`‚ùå Port selection error: ${portError.message}`);
                        updateConnectionStatus('disconnected', `Port selection failed: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`‚úÖ Port selected: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                if (portInfo.usbVendorId === 0x0483 && portInfo.usbProductId === 0x5740) {
                    logCommand('üéØ tinySA device confirmed! (VID=0x0483, PID=0x5740)');
                } else if (portInfo.usbVendorId === 0x0483) {
                    logCommand('‚ö†Ô∏è STM32-based device detected (likely tinySA)');
                } else {
                    logCommand('‚ùì Unknown device. Continuing...');
                }

                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = selectedBaudRate === 'auto' ? 9600 : parseInt(selectedBaudRate);

                updateConnectionStatus('connecting', `Step 2: Connecting at ${baudRate} bps...`);
                logCommand(`üîß Baud rate: ${baudRate} bps`);

                await cleanupConnection();
                
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                logCommand(`üì° Port opened successfully (${baudRate} bps)`);

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                logCommand(`   ‚Ä¢ Reader/Writer setup complete`);

                await sleep(300);

                updateConnectionStatus('connecting', `Step 3: Communication test (${baudRate} bps)`);
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    logCommand(`‚úÖ Connection successful!`);
                    updateConnectionStatus('connected', `tinySA connected (${baudRate} bps)`);
                    
                    await basicInitialize();
                    return;
                } else {
                    throw new Error('Communication test failed');
                }
                
            } catch (error) {
                updateConnectionStatus('disconnected', `Connection failed: ${error.message}`);
                logCommand(`üö® Final connection failure: ${error.message}`);
                await cleanupConnection();
            }
        }

        // Quick connection test
        async function quickConnectionTest() {
            try {
                logCommand('üîÑ Communication test started...');
                
                await sleep(100);
                
                logCommand('   üì§ Test 1: Sending CR');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response1 = await readWithQuickTimeout(1500);
                logCommand(`   üì• Response 1: "${response1}" (length: ${response1.length})`);
                
                logCommand('   üì§ Test 2: Sending CRLF');
                await writer.write(new TextEncoder().encode('\r\n'));
                
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`   üì• Response 2: "${response2}" (length: ${response2.length})`);
                
                const combinedResponse = response1 + response2;
                logCommand(`   üîç Combined analysis: "${combinedResponse}"`);
                
                if (combinedResponse.includes('ch>') || 
                    combinedResponse.includes('Ch>') || 
                    combinedResponse.includes('CH>')) {
                    logCommand('   ‚úÖ tinySA prompt "ch>" confirmed');
                    return true;
                } else if (combinedResponse.includes('>')) {
                    logCommand('   ‚úÖ General prompt ">" confirmed (likely tinySA)');
                    return true;
                } else if (combinedResponse.length > 0) {
                    logCommand('   ‚ö†Ô∏è Response received but prompt format different');
                    if (combinedResponse.length > 3) {
                        logCommand('   üîÑ Response sufficient, attempting connection');
                        return true;
                    }
                    return false;
                } else {
                    logCommand('   ‚ùå No response');
                    return false;
                }
                
            } catch (error) {
                logCommand(`‚ùå Connection test failed: ${error.message}`);
                return false;
            }
        }

        // Basic initialization
        async function basicInitialize() {
            try {
                logCommand('üîß Basic initialization started...');
                
                await sleep(200);
                await sendCommandSafe('resume', 1000);
                await sleep(200);
                
                logCommand('‚úÖ Basic initialization complete');
                
            } catch (error) {
                logCommand(`‚ö†Ô∏è Initialization warning: ${error.message} (normal operation possible)`);
            }
        }

        // Disconnect device
        async function disconnectDevice() {
            try {
                logCommand('üîå Disconnection started...');
                updateConnectionStatus('connecting', 'Disconnecting...');
                
                // Stop any ongoing operations
                if (isGenerating) {
                    await stopGeneration();
                }
                
                await cleanupConnection();
                serialPort = null;
                
                updateConnectionStatus('disconnected', 'Device disconnected successfully');
                
            } catch (error) {
                logCommand(`Disconnection error: ${error.message}`);
                updateConnectionStatus('disconnected', 'Disconnected (error occurred)');
            }
        }

        // Diagnose connection
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('‚ùå Device not connected');
                alert('Please connect device first.');
                return;
            }

            try {
                logCommand('üîç === Connection diagnosis started ===');
                
                logCommand('1Ô∏è‚É£ Basic communication check...');
                const basicTest = await sendCommandSafe('', 1000);
                logCommand(`   Basic response: "${basicTest || 'No response'}"`);

                logCommand('2Ô∏è‚É£ Prompt check...');
                const promptTest = await sendCommandSafe('\r', 1000);
                logCommand(`   Prompt: "${promptTest || 'No response'}"`);

                logCommand('3Ô∏è‚É£ Basic command test...');
                const resumeTest = await sendCommandSafe('resume', 2000);
                logCommand(`   Resume response: "${resumeTest || 'No response'}"`);

                logCommand('üîç === Diagnosis complete ===');
                
            } catch (error) {
                logCommand(`‚ùå Diagnosis error: ${error.message}`);
            }
        }

        // Clear log
        function clearLog() {
            document.getElementById('commandLog').textContent = '';
            logCommand('üìã Log cleared');
        }

        // Initialize chart
        function initChart() {
            try {
                logCommand('üìà Initializing chart...');
                
                const ctx = document.getElementById('spectrumChart').getContext('2d');
                if (!ctx) {
                    throw new Error('Cannot get canvas context');
                }
                
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Signal Strength (dBm)',
                            data: [],
                            borderColor: '#4a6cf7',
                            backgroundColor: 'rgba(74, 108, 247, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Frequency (MHz)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Signal Strength (dBm)',
                                    font: {
                                        size: 14,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                },
                                // Set Y-axis to default to 0dB maximum
                                max: 0,
                                min: -100
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const elementIndex = elements[0].index;
                                if (frequencies && frequencies[elementIndex] !== undefined && 
                                    spectrumData && spectrumData[elementIndex] !== undefined) {
                                    const frequency = frequencies[elementIndex];
                                    const amplitude = spectrumData[elementIndex];
                                    updateMarker(frequency, amplitude);
                                }
                            }
                        },
                        animation: {
                            duration: 500
                        }
                    }
                });
                
                logCommand('‚úÖ Chart initialized successfully');
                
                // Test chart with sample data
                testChart();
                
            } catch (error) {
                logCommand(`‚ùå Chart initialization failed: ${error.message}`);
                console.error('Chart init error:', error);
            }
        }

        // Test chart functionality
        function testChart() {
            try {
                logCommand('üß™ Testing chart with sample data...');
                
                const testFreqs = [1, 10, 50, 100, 500, 900];
                const testData = [-90, -85, -60, -70, -80, -95];
                
                chart.data.labels = testFreqs.map(f => f.toString());
                chart.data.datasets[0].data = testData;
                chart.update();
                
                logCommand('‚úÖ Chart test successful');
                
                // Clear test data after 2 seconds
                setTimeout(() => {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    logCommand('üóëÔ∏è Test data cleared');
                }, 2000);
                
            } catch (error) {
                logCommand(`‚ùå Chart test failed: ${error.message}`);
            }
        }

        // Debug chart status
        function debugChart() {
            logCommand('üîç === Chart Debug Information ===');
            logCommand(`Chart object exists: ${chart ? 'Yes' : 'No'}`);
            
            if (chart) {
                logCommand(`Chart type: ${chart.config.type}`);
                logCommand(`Data labels count: ${chart.data.labels ? chart.data.labels.length : 'undefined'}`);
                logCommand(`Dataset count: ${chart.data.datasets ? chart.data.datasets.length : 'undefined'}`);
                
                if (chart.data.datasets && chart.data.datasets[0]) {
                    logCommand(`Data points count: ${chart.data.datasets[0].data ? chart.data.datasets[0].data.length : 'undefined'}`);
                }
            }
            
            logCommand(`Global frequencies array: ${frequencies ? frequencies.length + ' points' : 'undefined'}`);
            logCommand(`Global spectrum data: ${spectrumData ? spectrumData.length + ' points' : 'undefined'}`);
            
            const canvas = document.getElementById('spectrumChart');
            logCommand(`Canvas element: ${canvas ? 'exists' : 'missing'}`);
            if (canvas) {
                logCommand(`Canvas size: ${canvas.width}x${canvas.height}`);
            }
        }

        // Generate frequencies
        function generateFrequencies(start, stop, points) {
            try {
                if (start >= stop) {
                    throw new Error(`Invalid frequency range: start (${start}) >= stop (${stop})`);
                }
                if (points < 2) {
                    throw new Error(`Invalid points count: ${points} (minimum 2)`);
                }
                
                const step = (stop - start) / (points - 1);
                const freqs = [];
                
                for (let i = 0; i < points; i++) {
                    const freq = start + i * step;
                    freqs.push(freq);
                }
                
                logCommand(`   Generated ${freqs.length} frequencies from ${freqs[0].toFixed(2)} to ${freqs[freqs.length-1].toFixed(2)} MHz`);
                
                return freqs;
            } catch (error) {
                logCommand(`‚ùå Frequency generation error: ${error.message}`);
                // Return fallback frequencies
                return [start || 1, stop || 900];
            }
        }

        // Simulate spectrum
        function simulateSpectrum() {
            try {
                logCommand('üéØ Generating simulation data...');
                
                // Get parameters with validation
                const startFreq = parseFloat(document.getElementById('startFreq').value) || 1;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) || 900;
                const points = parseInt(document.getElementById('scanPoints').value) || 101;
                const noiseLevel = parseFloat(document.getElementById('noiseLevel').value) || -80;

                const signal1Freq = parseFloat(document.getElementById('signal1Freq').value) || 100;
                const signal1Amp = parseFloat(document.getElementById('signal1Amp').value) || -20;
                const signal1Type = document.getElementById('signal1Type').value || 'sine';

                const signal2Freq = parseFloat(document.getElementById('signal2Freq').value) || 200;
                const signal2Amp = parseFloat(document.getElementById('signal2Amp').value) || -30;
                const signal2Type = document.getElementById('signal2Type').value || 'sine';

                logCommand(`   Parameters: ${startFreq}-${stopFreq} MHz, ${points} points, noise ${noiseLevel} dBm`);
                logCommand(`   Signal 1: ${signal1Freq} MHz at ${signal1Amp} dBm (${signal1Type})`);
                logCommand(`   Signal 2: ${signal2Freq} MHz at ${signal2Amp} dBm (${signal2Type})`);

                // Validate parameters
                if (startFreq >= stopFreq) {
                    throw new Error('Start frequency must be less than stop frequency');
                }
                if (points < 2 || points > 10000) {
                    throw new Error('Points must be between 2 and 10000');
                }

                // Generate frequency array
                const simFreqs = generateFrequencies(startFreq, stopFreq, points);
                const simData = [];

                logCommand(`   Generated ${simFreqs.length} frequency points`);

                // Generate spectrum data
                for (let i = 0; i < simFreqs.length; i++) {
                    const freq = simFreqs[i];
                    let amplitude = noiseLevel + (Math.random() - 0.5) * 10;

                    // Add signal 1
                    if (signal1Freq >= startFreq && signal1Freq <= stopFreq) {
                        const signal1Component = calculateSignalComponent(freq, signal1Freq, signal1Amp, signal1Type);
                        amplitude = combineSignals(amplitude, signal1Component);
                    }

                    // Add signal 2
                    if (signal2Freq >= startFreq && signal2Freq <= stopFreq) {
                        const signal2Component = calculateSignalComponent(freq, signal2Freq, signal2Amp, signal2Type);
                        amplitude = combineSignals(amplitude, signal2Component);
                    }

                    simData.push(amplitude);
                }

                logCommand(`   Generated ${simData.length} amplitude points`);
                logCommand(`   Amplitude range: ${Math.min(...simData).toFixed(1)} to ${Math.max(...simData).toFixed(1)} dBm`);

                return { 
                    frequencies: simFreqs, 
                    spectrum: simData 
                };

            } catch (error) {
                logCommand(`‚ùå Simulation error: ${error.message}`);
                logCommand('üÜò Using emergency fallback data...');
                
                // Emergency fallback data
                return {
                    frequencies: [1, 100, 200, 500, 900],
                    spectrum: [-90, -60, -70, -80, -95]
                };
            }
        }

        // Calculate signal component
        function calculateSignalComponent(currentFreq, signalFreq, signalAmp, signalType) {
            try {
                const freqDiff = Math.abs(currentFreq - signalFreq);
                let component = -100; // Default low value

                switch (signalType) {
                    case 'sine':
                        if (freqDiff < 5) {
                            component = signalAmp - (freqDiff * freqDiff * 2);
                        }
                        break;
                    case 'square':
                        if (freqDiff < 5) {
                            component = signalAmp - (freqDiff * freqDiff * 1.5);
                        }
                        // Add harmonics
                        for (let harmonic = 3; harmonic <= 9; harmonic += 2) {
                            const harmonicFreq = signalFreq * harmonic;
                            const harmonicDiff = Math.abs(currentFreq - harmonicFreq);
                            if (harmonicDiff < 2) {
                                const harmonicAmp = signalAmp - 20 * Math.log10(harmonic) - harmonicDiff * 10;
                                component = combineSignals(component, harmonicAmp);
                            }
                        }
                        break;
                    case 'noise':
                        component = signalAmp + (Math.random() - 0.5) * 20;
                        break;
                    default:
                        component = -100;
                }

                return component;
            } catch (error) {
                logCommand(`‚ö†Ô∏è Signal component calculation error: ${error.message}`);
                return -100; // Safe fallback
            }
        }

        // Combine signals (dB scale)
        function combineSignals(signal1_dB, signal2_dB) {
            try {
                // Validate inputs
                if (isNaN(signal1_dB) || isNaN(signal2_dB)) {
                    return Math.max(signal1_dB || -100, signal2_dB || -100);
                }
                
                // Prevent extreme values
                signal1_dB = Math.max(-200, Math.min(100, signal1_dB));
                signal2_dB = Math.max(-200, Math.min(100, signal2_dB));
                
                const power1 = Math.pow(10, signal1_dB / 10);
                const power2 = Math.pow(10, signal2_dB / 10);
                const totalPower = power1 + power2;
                
                if (totalPower <= 0) {
                    return -100;
                }
                
                const result = 10 * Math.log10(totalPower);
                
                // Validate result
                if (isNaN(result) || !isFinite(result)) {
                    return Math.max(signal1_dB, signal2_dB);
                }
                
                return result;
            } catch (error) {
                logCommand(`‚ö†Ô∏è Signal combination error: ${error.message}`);
                return Math.max(signal1_dB || -100, signal2_dB || -100);
            }
        }

        // Start scan
        async function startScan() {
            if (isScanning || currentMode !== 'analyzer') {
                logCommand('‚ùå Cannot start scan: ' + (isScanning ? 'Already scanning' : 'Not in analyzer mode'));
                return;
            }
            
            isScanning = true;
            document.getElementById('statusDisplay').textContent = 'Scanning...';
            logCommand('üîÑ Starting spectrum scan...');
            
            try {
                const deviceMode = document.getElementById('deviceMode').value;
                let data = null;

                if (deviceMode === 'hardware' && isConnected) {
                    logCommand('üîó Hardware mode: Receiving data from real tinySA...');
                    try {
                        data = await getHardwareSpectrum();
                        
                        if (data && data.frequencies && data.frequencies.length > 0) {
                            logCommand(`‚úÖ Hardware data received successfully: ${data.frequencies.length} points`);
                        } else {
                            logCommand('‚ö†Ô∏è Hardware data invalid, switching to simulation');
                            data = null;
                        }
                    } catch (hwError) {
                        logCommand(`‚ùå Hardware scan failed: ${hwError.message}`);
                        data = null;
                    }
                }
                
                // If hardware failed or simulation mode, use simulation
                if (!data) {
                    logCommand('üéØ Using simulation data...');
                    
                    // Update temperature simulation
                    const temp = 25 + (Math.random() - 0.5) * 10;
                    document.getElementById('temperature').value = temp.toFixed(1);
                    
                    // Simulate scan delay
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    data = simulateSpectrum();
                    logCommand(`üìä Simulation generated ${data.frequencies.length} data points`);
                }
                
                // Validate data before updating chart
                if (!data || !data.frequencies || !data.spectrum || 
                    data.frequencies.length === 0 || data.spectrum.length === 0) {
                    throw new Error('Invalid spectrum data generated');
                }
                
                // Update global variables
                frequencies = data.frequencies;
                spectrumData = data.spectrum;
                
                logCommand(`üìà Updating chart with ${frequencies.length} points`);
                logCommand(`   Frequency range: ${frequencies[0].toFixed(2)} - ${frequencies[frequencies.length-1].toFixed(2)} MHz`);
                logCommand(`   Amplitude range: ${Math.min(...spectrumData).toFixed(1)} - ${Math.max(...spectrumData).toFixed(1)} dBm`);
                
                // Update chart
                chart.data.labels = data.frequencies.map(f => f.toFixed(1));
                chart.data.datasets[0].data = data.spectrum;
                
                // Force chart update
                chart.update('active');
                
                // Update status
                const statusMsg = `Scan complete - ${data.frequencies.length} points, range: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                document.getElementById('statusDisplay').textContent = statusMsg;
                
                logCommand('‚úÖ Scan completed successfully');
                
            } catch (error) {
                const errorMsg = `Scan error: ${error.message}`;
                document.getElementById('statusDisplay').textContent = errorMsg;
                logCommand(`‚ùå ${errorMsg}`);
                logCommand('üîß Debug info:');
                logCommand(`   - Current mode: ${currentMode}`);
                logCommand(`   - Device mode: ${document.getElementById('deviceMode').value}`);
                logCommand(`   - Connected: ${isConnected}`);
                logCommand(`   - Chart object: ${chart ? 'exists' : 'missing'}`);
                
                // Try to generate minimal fallback data
                try {
                    logCommand('üÜò Attempting fallback data generation...');
                    const fallbackData = {
                        frequencies: [1, 50, 100, 200, 500, 900],
                        spectrum: [-90, -85, -60, -70, -80, -95]
                    };
                    
                    frequencies = fallbackData.frequencies;
                    spectrumData = fallbackData.spectrum;
                    
                    chart.data.labels = fallbackData.frequencies.map(f => f.toString());
                    chart.data.datasets[0].data = fallbackData.spectrum;
                    chart.update();
                    
                    logCommand('‚úÖ Fallback data loaded successfully');
                } catch (fallbackError) {
                    logCommand(`‚ùå Fallback data failed: ${fallbackError.message}`);
                }
            } finally {
                isScanning = false;
                logCommand('üèÅ Scan process finished');
            }
        }

        // Get hardware spectrum
        async function getHardwareSpectrum() {
            try {
                const startFreq = parseFloat(document.getElementById('startFreq').value) * 1e6;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) * 1e6;
                const points = parseInt(document.getElementById('scanPoints').value);

                logCommand('üì° === Hardware spectrum measurement started ===');
                logCommand(`Setting range: ${startFreq/1e6} - ${stopFreq/1e6} MHz, ${points} points`);

                await sendCommandSafe('pause');
                await sleep(200);

                await sendCommandSafe(`sweep start ${Math.floor(startFreq)}`);
                await sleep(100);
                await sendCommandSafe(`sweep stop ${Math.floor(stopFreq)}`);
                await sleep(100);

                await sendCommandSafe('resume');
                
                const scanTime = Math.max(1000, points * 5);
                logCommand(`   Waiting for scan completion... (${scanTime}ms)`);
                await sleep(scanTime);

                const freqResponse = await sendCommandSafe('frequencies', 5000);
                const dataResponse = await sendCommandSafe('data 0', 5000);
                
                if (!freqResponse || !dataResponse) {
                    throw new Error('Failed to get spectrum data');
                }

                // Parse data
                const freqLines = freqResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const dataLines = dataResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const minLength = Math.min(freqLines.length, dataLines.length);
                const freqs = freqLines.slice(0, minLength).map(freq => freq / 1e6);
                const spectrum = dataLines.slice(0, minLength);

                logCommand('üì° === Hardware spectrum measurement complete ===');
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`‚ùå Hardware scan error: ${error.message}`);
                return simulateSpectrum();
            }
        }

        // Signal generator functions
        async function startGeneration() {
            if (isGenerating || currentMode !== 'generator') return;
            
            const freq = parseFloat(document.getElementById('genFreq').value);
            const level = parseFloat(document.getElementById('genLevel').value);
            const mode = document.getElementById('genMode').value;
            const modulation = document.getElementById('modulation').value;
            
            if (mode === 'off') {
                alert('Please set output mode to ON first');
                return;
            }
            
            isGenerating = true;
            document.getElementById('genStatus').className = 'status-indicator connecting';
            document.getElementById('genStatus').textContent = 'Output ON';
            
            try {
                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    // Real hardware commands
                    await sendCommandSafe(`sweep stop`); // Stop any sweep
                    await sendCommandSafe(`freq ${freq * 1e6}`); // Set frequency in Hz
                    await sendCommandSafe(`level ${level}`); // Set level
                    await sendCommandSafe(`output on`); // Enable output
                    
                    if (modulation === 'sweep') {
                        const sweepStart = parseFloat(document.getElementById('sweepStart').value) * 1e6;
                        const sweepStop = parseFloat(document.getElementById('sweepStop').value) * 1e6;
                        const sweepTime = parseFloat(document.getElementById('sweepTime').value);
                        
                        await sendCommandSafe(`sweep start ${sweepStart}`);
                        await sendCommandSafe(`sweep stop ${sweepStop}`);
                        await sendCommandSafe(`sweep time ${sweepTime}`);
                        await sendCommandSafe(`sweep`);
                    }
                    
                    logCommand(`‚úÖ Hardware signal generation started: ${freq} MHz at ${level} dBm`);
                } else {
                    // Simulation
                    logCommand(`üéØ Simulation: Generating ${freq} MHz at ${level} dBm (${modulation})`);
                }
                
                // Update UI
                document.getElementById('currentGenFreq').value = `${freq} MHz`;
                document.getElementById('currentGenLevel').value = `${level} dBm`;
                document.getElementById('genStatus').className = 'status-indicator connected';
                
                // Update monitoring
                await updateMonitoring();
                
                document.getElementById('statusDisplay').textContent = 
                    `Signal generation active: ${freq} MHz at ${level} dBm`;
                
            } catch (error) {
                logCommand(`‚ùå Signal generation error: ${error.message}`);
                isGenerating = false;
                document.getElementById('genStatus').className = 'status-indicator disconnected';
                document.getElementById('genStatus').textContent = 'Output OFF';
            }
        }

        async function stopGeneration() {
            if (!isGenerating) return;
            
            try {
                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    await sendCommandSafe('output off');
                    logCommand('‚úÖ Hardware signal generation stopped');
                } else {
                    logCommand('üõë Simulation: Signal generation stopped');
                }
                
                isGenerating = false;
                document.getElementById('genStatus').className = 'status-indicator disconnected';
                document.getElementById('genStatus').textContent = 'Output OFF';
                document.getElementById('currentGenFreq').value = '--';
                document.getElementById('currentGenLevel').value = '--';
                document.getElementById('powerMonitor').value = '-- dBm';
                document.getElementById('vswr').value = '--';
                
                document.getElementById('statusDisplay').textContent = 'Signal generation stopped';
                
            } catch (error) {
                logCommand(`‚ùå Stop generation error: ${error.message}`);
            }
        }

        async function emergencyStop() {
            try {
                if (isConnected) {
                    await sendCommandSafe('output off');
                    await sendCommandSafe('sweep stop');
                }
                
                isGenerating = false;
                document.getElementById('genStatus').className = 'status-indicator disconnected';
                document.getElementById('genStatus').textContent = 'EMERGENCY STOP';
                
                logCommand('üö® EMERGENCY STOP executed');
                document.getElementById('statusDisplay').textContent = 'EMERGENCY STOP - All outputs disabled';
                
            } catch (error) {
                logCommand(`‚ùå Emergency stop error: ${error.message}`);
            }
        }

        async function updateMonitoring() {
            try {
                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    // Real monitoring commands
                    const powerResponse = await sendCommandSafe('power', 1000);
                    const vswrResponse = await sendCommandSafe('vswr', 1000);
                    
                    if (powerResponse) {
                        document.getElementById('powerMonitor').value = `${powerResponse} dBm`;
                    }
                    if (vswrResponse) {
                        document.getElementById('vswr').value = vswrResponse;
                    }
                } else {
                    // Simulation values
                    if (isGenerating) {
                        const level = parseFloat(document.getElementById('genLevel').value);
                        const simulatedPower = level + (Math.random() - 0.5) * 2;
                        const simulatedVSWR = 1.1 + Math.random() * 0.5;
                        
                        document.getElementById('powerMonitor').value = `${simulatedPower.toFixed(1)} dBm`;
                        document.getElementById('vswr').value = simulatedVSWR.toFixed(2);
                    }
                }
            } catch (error) {
                logCommand(`‚ùå Monitoring update error: ${error.message}`);
            }
        }

        // Update marker
        function updateMarker(frequency, amplitude) {
            document.getElementById('markerInfo').innerHTML = `
                <strong>Frequency:</strong> ${frequency.toFixed(2)} MHz<br>
                <strong>Amplitude:</strong> ${amplitude.toFixed(1)} dBm
            `;
        }

        // Download CSV
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('Please run a scan first.');
                return;
            }

            let csvContent = "Frequency(MHz),Signal Strength(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Apply advanced settings
        async function applyAdvancedSettings() {
            try {
                const inputMode = document.getElementById('inputMode').value;
                const rbw = document.getElementById('rbw').value;

                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    await sendCommandSafe(`mode ${inputMode} input`);
                    
                    if (rbw === 'auto') {
                        await sendCommandSafe('rbw auto');
                    } else {
                        await sendCommandSafe(`rbw ${rbw}`);
                    }
                    
                    logCommand('Hardware settings applied');
                } else {
                    logCommand(`Simulation: Input mode ${inputMode}, RBW ${rbw}`);
                }
                
                document.getElementById('statusDisplay').textContent = 'Advanced settings applied';
                
            } catch (error) {
                logCommand(`Settings application error: ${error.message}`);
            }
        }

        // Test data generation
        function testDataGeneration() {
            logCommand('üß™ === Testing Data Generation ===');
            
            try {
                // Test basic data generation
                logCommand('1Ô∏è‚É£ Testing basic data generation...');
                const testData = simulateSpectrum();
                
                if (testData && testData.frequencies && testData.spectrum) {
                    logCommand(`‚úÖ Data generation successful:`);
                    logCommand(`   Frequencies: ${testData.frequencies.length} points`);
                    logCommand(`   Spectrum: ${testData.spectrum.length} points`);
                    logCommand(`   Freq range: ${testData.frequencies[0].toFixed(2)} - ${testData.frequencies[testData.frequencies.length-1].toFixed(2)} MHz`);
                    logCommand(`   Amplitude range: ${Math.min(...testData.spectrum).toFixed(1)} - ${Math.max(...testData.spectrum).toFixed(1)} dBm`);
                    
                    // Test chart update
                    logCommand('2Ô∏è‚É£ Testing chart update...');
                    if (chart) {
                        chart.data.labels = testData.frequencies.map(f => f.toFixed(1));
                        chart.data.datasets[0].data = testData.spectrum;
                        chart.update('active');
                        
                        // Update globals
                        frequencies = testData.frequencies;
                        spectrumData = testData.spectrum;
                        
                        logCommand('‚úÖ Chart update successful');
                        
                        // Update status
                        document.getElementById('statusDisplay').textContent = 
                            `Test data loaded - ${testData.frequencies.length} points`;
                            
                    } else {
                        logCommand('‚ùå Chart object not available');
                    }
                } else {
                    logCommand('‚ùå Data generation failed - invalid data structure');
                }
                
            } catch (error) {
                logCommand(`‚ùå Test failed: ${error.message}`);
                console.error('Test data generation error:', error);
            }
            
            logCommand('üß™ === Test Complete ===');
        }

        // Get temperature
        async function getTemperature() {
            try {
                if (isConnected && document.getElementById('deviceMode').value === 'hardware') {
                    const response = await sendCommandSafe('k');
                    if (response) {
                        const temp = parseFloat(response);
                        if (!isNaN(temp)) {
                            document.getElementById('temperature').value = temp.toFixed(1);
                            logCommand(`Hardware temperature: ${temp.toFixed(1)}¬∞C`);
                        } else {
                            logCommand(`Temperature parsing error: "${response}"`);
                        }
                    }
                } else {
                    const temp = 25 + (Math.random() - 0.5) * 15;
                    document.getElementById('temperature').value = temp.toFixed(1);
                    logCommand(`Simulation temperature: ${temp.toFixed(1)}¬∞C`);
                }
            } catch (error) {
                logCommand(`Temperature measurement error: ${error.message}`);
            }
        }

        // Page load initialization
        window.addEventListener('load', function() {
            logCommand('üöÄ === System Initialization Started ===');
            
            try {
                // Initialize chart first
                initChart();
                
                console.log('=== tinySA Spectrum Analyzer & Signal Generator Debug Mode ===');
                console.log('Detailed information available in console and UI log.');
                
                if (!('serial' in navigator)) {
                    document.getElementById('deviceMode').innerHTML = '<option value="simulation">Simulation Mode (Web Serial API not supported)</option>';
                    logCommand('‚ùå Warning: This browser does not support Web Serial API.');
                    logCommand('üîß Solution: Use Chrome, Edge, Opera browsers.');
                    console.error('Web Serial API not supported. Browser:', navigator.userAgent);
                } else {
                    logCommand('‚úÖ Web Serial API supported');
                    logCommand('üìå === tinySA Connection Guide ===');
                    logCommand('1Ô∏è‚É£ Check COM port baud rate in Windows Device Manager');
                    logCommand('2Ô∏è‚É£ Select correct baud rate in dropdown above');
                    logCommand('3Ô∏è‚É£ Connect tinySA with data USB cable');
                    logCommand('4Ô∏è‚É£ Ensure tinySA is powered on and displaying normal screen');
                    logCommand('5Ô∏è‚É£ Select "Hardware Connection" mode');
                    logCommand('6Ô∏è‚É£ Click "Connect" button');
                    logCommand('7Ô∏è‚É£ Select appropriate port in popup');
                    logCommand('8Ô∏è‚É£ Use "Diagnose" after connection');
                    console.log('Web Serial API supported. Ready for tinySA connection.');
                }
                
                if ('serial' in navigator) {
                    navigator.serial.addEventListener('disconnect', (event) => {
                        if (event.target === serialPort) {
                            updateConnectionStatus('disconnected', 'üîå Device disconnected (check USB cable)');
                            console.warn('tinySA disconnected unexpectedly');
                            serialPort = null;
                            reader = null;
                            writer = null;
                            
                            if (isGenerating) {
                                stopGeneration();
                            }
                        }
                    });
                    
                    navigator.serial.getPorts().then(ports => {
                        if (ports.length > 0) {
                            logCommand(`üí° Found ${ports.length} previously authorized ports`);
                            console.log('Previously authorized ports:', ports);
                        }
                    }).catch(err => {
                        console.error('Error checking existing ports:', err);
                    });
                }
                
                // Wait a bit for chart to be fully ready, then run initial scan
                setTimeout(() => {
                    if (currentMode === 'analyzer') {
                        logCommand('üîÑ Running initial scan...');
                        startScan();
                    }
                }, 1000);
                
                logCommand('‚úÖ System initialization complete');
                console.log('tinySA Analyzer & Generator initialized successfully');
                
            } catch (error) {
                logCommand(`‚ùå Initialization error: ${error.message}`);
                console.error('Initialization error:', error);
            }
        });

        // Real-time updates
        setInterval(() => {
            if (!isScanning && !isGenerating) {
                const currentTemp = parseFloat(document.getElementById('temperature').value);
                const newTemp = currentTemp + (Math.random() - 0.5) * 0.5;
                document.getElementById('temperature').value = newTemp.toFixed(1);
            }
            
            // Update monitoring in generator mode
            if (isGenerating && currentMode === 'generator') {
                updateMonitoring();
            }
        }, 5000);
    </script>
</body>
</html>
