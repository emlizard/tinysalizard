<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TinySA Spectrum Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --accent: #06b6d4;
            --accent-dark: #0891b2;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-light: #ffffff;
            --bg-dark: #0f172a;
            --surface-light: #f8fafc;
            --surface-dark: #1e293b;
            --card-light: #ffffff;
            --card-dark: #334155;
            --text-primary-light: #0f172a;
            --text-primary-dark: #f1f5f9;
            --text-secondary-light: #64748b;
            --text-secondary-dark: #94a3b8;
            --border-light: #e2e8f0;
            --border-dark: #475569;
            --shadow-light: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-medium: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-large: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius: 12px;
            --radius-lg: 16px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="light"] {
            --bg: var(--bg-light);
            --surface: var(--surface-light);
            --card: var(--card-light);
            --text-primary: var(--text-primary-light);
            --text-secondary: var(--text-secondary-light);
            --border: var(--border-light);
            --shadow: var(--shadow-light);
        }

        [data-theme="dark"] {
            --bg: var(--bg-dark);
            --surface: var(--surface-dark);
            --card: var(--card-dark);
            --text-primary: var(--text-primary-dark);
            --text-secondary: var(--text-secondary-dark);
            --border: var(--border-dark);
            --shadow: var(--shadow-medium);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            line-height: 1.6;
            transition: var(--transition);
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                45deg,
                rgba(37, 99, 235, 0.03) 0%,
                rgba(6, 182, 212, 0.03) 50%,
                rgba(16, 185, 129, 0.03) 100%
            );
            z-index: -1;
            animation: gradientShift 8s ease-in-out infinite;
        }

        @keyframes gradientShift {
            0%, 100% { transform: translateX(0%) rotate(0deg); }
            50% { transform: translateX(5%) rotate(1deg); }
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            z-index: 100;
            transition: var(--transition);
        }

        [data-theme="dark"] .header {
            background: rgba(15, 23, 42, 0.9);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .page-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theme-toggle {
            background: none;
            border: 2px solid var(--border);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            color: var(--text-secondary);
        }

        .theme-toggle:hover {
            border-color: var(--primary);
            color: var(--primary);
            transform: scale(1.1);
        }

        /* Main Content */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        .hero {
            text-align: center;
            margin-bottom: 3rem;
        }

        .hero h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.2;
        }

        .hero p {
            font-size: 1.125rem;
            color: var(--text-secondary);
            max-width: 700px;
            margin: 0 auto 1rem;
        }

        /* Card System */
        .card {
            background: var(--card);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 2rem;
            margin-bottom: 2rem;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transform: scaleX(0);
            transition: var(--transition);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-large);
        }

        .card:hover::before {
            transform: scaleX(1);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border-radius: var(--radius);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.9rem;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .grid-2 {
            grid-template-columns: 1fr 2fr;
        }

        /* Form Controls */
        .input-group {
            margin-bottom: 1.5rem;
        }

        .input-label {
            display: block;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg);
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .input-group-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 0.75rem;
            align-items: end;
        }

        .input-unit {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
            display: flex;
            align-items: center;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--success), var(--accent));
        }

        .btn-full {
            width: 100%;
            justify-content: center;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        /* Status Indicator */
        .status-indicator {
            padding: 0.75rem 1rem;
            border-radius: var(--radius);
            font-weight: 600;
            text-align: center;
            margin-bottom: 1rem;
            transition: var(--transition);
        }

        .status-indicator.connected {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            border: 2px solid rgba(16, 185, 129, 0.2);
        }

        .status-indicator.disconnected {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
            border: 2px solid rgba(239, 68, 68, 0.2);
        }

        .status-indicator.connecting {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning);
            border: 2px solid rgba(245, 158, 11, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Chart Container */
        .chart-container {
            background: var(--card);
            border-radius: var(--radius-lg);
            padding: 2rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
        }

        .chart-wrapper {
            position: relative;
            height: 500px;
            width: 100%;
            margin-top: 1rem;
        }

        /* Marker Info */
        .marker-info {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(6, 182, 212, 0.1));
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-top: 1.5rem;
        }

        .marker-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .marker-content {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Command Log */
        .command-log {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--success);
            margin-top: 1rem;
        }

        .command-log::-webkit-scrollbar {
            width: 6px;
        }

        .command-log::-webkit-scrollbar-track {
            background: var(--surface);
        }

        .command-log::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        /* Debug Info */
        .debug-info {
            background: rgba(6, 182, 212, 0.1);
            border-left: 4px solid var(--accent);
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0 var(--radius) var(--radius) 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent);
        }

        /* Status Bar */
        .status-bar {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 1rem;
            margin-top: 2rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-in {
            animation: fadeInUp 0.6s ease-out;
        }

        /* Loading State */
        .calculating {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .calculating::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            border-top-color: transparent;
            transform: translate(-50%, -50%);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 968px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }

            .btn-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .card {
                padding: 1.5rem;
            }

            .hero h1 {
                font-size: 2rem;
            }

            .input-group-row {
                grid-template-columns: 1fr;
            }

            .input-unit {
                justify-content: center;
            }
        }

        /* Error Display */
        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card);
            border: 2px solid var(--error);
            border-radius: var(--radius);
            padding: 1rem;
            z-index: 1000;
            animation: fadeInUp 0.3s ease-out;
            box-shadow: var(--shadow-large);
            max-width: 300px;
            color: var(--error);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1 class="page-title">
                <i class="fas fa-chart-line"></i>
                TinySA Spectrum Analyzer
            </h1>
            <button class="theme-toggle" onclick="toggleTheme()" title="í…Œë§ˆ ì „í™˜">
                <i class="fas fa-moon" id="theme-icon"></i>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <!-- Hero Section -->
        <div class="hero animate-in">
            <h1>RF ì‹ í˜¸ ë¶„ì„ ë„êµ¬</h1>
            <p>TinySAì™€ ì—°ê²°í•˜ì—¬ ì‹¤ì‹œê°„ ìŠ¤í™íŠ¸ëŸ¼ ë¶„ì„ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤</p>
        </div>

        <!-- Main Grid -->
        <div class="grid grid-2">
            <!-- Control Panel -->
            <div class="card animate-in">
                <h2 class="card-title">
                    <div class="card-icon">
                        <i class="fas fa-cogs"></i>
                    </div>
                    ì¥ì¹˜ ì œì–´
                </h2>

                <!-- Connection Status -->
                <div class="input-group">
                    <label class="input-label">ì—°ê²° ìƒíƒœ</label>
                    <div id="connectionStatus" class="status-indicator disconnected">
                        <i class="fas fa-circle"></i> ì—°ê²° ì•ˆë¨
                    </div>
                </div>

                <!-- Baud Rate -->
                <div class="input-group">
                    <label class="input-label">ë³´ë“œë ˆì´íŠ¸</label>
                    <select id="baudRate" class="input-field">
                        <option value="9600" selected>9600 bps (ì‹œìŠ¤í…œ ê¸°ë³¸ê°’)</option>
                        <option value="19200">19200 bps</option>
                        <option value="38400">38400 bps</option>
                        <option value="57600">57600 bps</option>
                        <option value="115200">115200 bps (tinySA í‘œì¤€)</option>
                        <option value="230400">230400 bps</option>
                    </select>
                </div>

                <!-- Connection Buttons -->
                <div class="btn-grid">
                    <button class="btn btn-full" id="connectBtn" onclick="connectDevice()">
                        <i class="fas fa-plug"></i> ì—°ê²°
                    </button>
                    <button class="btn btn-secondary btn-full" id="disconnectBtn" onclick="disconnectDevice()" disabled>
                        <i class="fas fa-times"></i> ì—°ê²° í•´ì œ
                    </button>
                </div>

                <div class="btn-grid">
                    <button class="btn btn-secondary btn-full" onclick="diagnoseConnection()" id="diagnoseBtn" disabled>
                        <i class="fas fa-stethoscope"></i> ì§„ë‹¨
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="clearLog()">
                        <i class="fas fa-trash"></i> ë¡œê·¸ ì§€ìš°ê¸°
                    </button>
                </div>

                <hr style="margin: 2rem 0; border: none; height: 1px; background: var(--border);">

                <!-- Frequency Settings -->
                <h3 class="card-title" style="font-size: 1.25rem; margin-bottom: 1rem;">
                    <div class="card-icon" style="width: 24px; height: 24px; font-size: 0.8rem;">
                        <i class="fas fa-wave-square"></i>
                    </div>
                    ì£¼íŒŒìˆ˜ ì„¤ì •
                </h3>

                <div class="input-group">
                    <label class="input-label">ì‹œì‘ ì£¼íŒŒìˆ˜</label>
                    <div class="input-group-row">
                        <input type="number" id="startFreq" class="input-field" value="1" step="0.1">
                        <div class="input-unit">MHz</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">ì¢…ë£Œ ì£¼íŒŒìˆ˜</label>
                    <div class="input-group-row">
                        <input type="number" id="stopFreq" class="input-field" value="900" step="0.1">
                        <div class="input-unit">MHz</div>
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">ìŠ¤ìº” í¬ì¸íŠ¸</label>
                    <select id="scanPoints" class="input-field">
                        <option value="101">101 í¬ì¸íŠ¸</option>
                        <option value="201">201 í¬ì¸íŠ¸</option>
                        <option value="301">301 í¬ì¸íŠ¸</option>
                        <option value="501">501 í¬ì¸íŠ¸</option>
                        <option value="801">801 í¬ì¸íŠ¸</option>
                    </select>
                </div>

                <!-- Scan Buttons -->
                <div class="btn-grid">
                    <button class="btn btn-full" onclick="startScan()">
                        <i class="fas fa-search"></i> ìŠ¤ìº” ì‹œì‘
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="downloadCSV()">
                        <i class="fas fa-download"></i> CSV ì €ì¥
                    </button>
                </div>

                <div class="btn-grid">
                    <button class="btn btn-secondary btn-full" onclick="testChart()">
                        <i class="fas fa-vial"></i> ì°¨íŠ¸ í…ŒìŠ¤íŠ¸
                    </button>
                    <button class="btn btn-secondary btn-full" onclick="debugChart()">
                        <i class="fas fa-bug"></i> ì°¨íŠ¸ ë””ë²„ê·¸
                    </button>
                </div>

                <!-- Marker Info -->
                <div class="marker-info">
                    <h3 class="marker-title">
                        <i class="fas fa-crosshairs"></i>
                        ë§ˆì»¤ ì •ë³´
                    </h3>
                    <div id="markerInfo" class="marker-content">
                        ì°¨íŠ¸ë¥¼ í´ë¦­í•˜ì—¬ ë§ˆì»¤ë¥¼ ì„¤ì •í•˜ì„¸ìš”
                    </div>
                </div>

                <!-- Command Log -->
                <div class="input-group">
                    <label class="input-label">ëª…ë ¹ ë¡œê·¸</label>
                    <div id="commandLog" class="command-log">ì‹œìŠ¤í…œ ì¤€ë¹„ë¨...\n</div>
                </div>

                <!-- Debug Info -->
                <div class="debug-info" id="debugInfo">
                    ì°¨íŠ¸ ìƒíƒœ: ì¤€ë¹„ ì¤‘...
                </div>
            </div>

            <!-- Chart Panel -->
            <div class="chart-container animate-in">
                <h2 class="card-title">
                    <div class="card-icon">
                        <i class="fas fa-chart-area"></i>
                    </div>
                    ìŠ¤í™íŠ¸ëŸ¼ ë¶„ì„
                </h2>
                <div class="chart-wrapper">
                    <canvas id="spectrumChart"></canvas>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div id="statusDisplay">ì‹œìŠ¤í…œ ì¤€ë¹„ë¨ - ìŠ¤ìº”ì„ ì‹œì‘í•˜ì„¸ìš”</div>
        </div>
    </div>

    <script>
        let chart;
        let spectrumData = [];
        let frequencies = [];
        let isScanning = false;
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;

        // TinySA ì¥ì¹˜ ì‹ë³„ì
        const TINYSA_VID = 0x0483;
        const TINYSA_PID = 0x5740;

        // Theme Toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            html.setAttribute('data-theme', newTheme);
            
            const icon = document.getElementById('theme-icon');
            icon.className = newTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
            
            localStorage.setItem('theme', newTheme);
        }

        // Initialize theme from localStorage
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            const icon = document.getElementById('theme-icon');
            icon.className = savedTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
        }

        // Step 1: ë””ë²„ê·¸ í—¬í¼ í•¨ìˆ˜ë“¤
        function updateDebugInfo(message) {
            const debugElement = document.getElementById('debugInfo');
            if (debugElement) {
                debugElement.textContent = message;
            }
            logCommand(`ğŸ”§ DEBUG: ${message}`);
        }

        function debugChart() {
            logCommand('ğŸ” === ì°¨íŠ¸ ë””ë²„ê·¸ ì‹œì‘ ===');
            
            updateDebugInfo('ì°¨íŠ¸ ë””ë²„ê·¸ ì‹¤í–‰ ì¤‘...');
            
            // ê¸°ë³¸ ì •ë³´
            logCommand(`ì°¨íŠ¸ ê°ì²´ ì¡´ì¬: ${chart ? 'YES' : 'NO'}`);
            logCommand(`Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬: ${typeof Chart !== 'undefined' ? 'YES' : 'NO'}`);
            
            // ìº”ë²„ìŠ¤ ì •ë³´
            const canvas = document.getElementById('spectrumChart');
            logCommand(`ìº”ë²„ìŠ¤ ìš”ì†Œ ì¡´ì¬: ${canvas ? 'YES' : 'NO'}`);
            
            if (canvas) {
                logCommand(`ìº”ë²„ìŠ¤ í¬ê¸°: ${canvas.width}x${canvas.height}`);
                logCommand(`ìº”ë²„ìŠ¤ ë¶€ëª¨ í¬ê¸°: ${canvas.parentElement.clientWidth}x${canvas.parentElement.clientHeight}`);
                
                const ctx = canvas.getContext('2d');
                logCommand(`ì»¨í…ìŠ¤íŠ¸ ì¡´ì¬: ${ctx ? 'YES' : 'NO'}`);
            }
            
            // ì°¨íŠ¸ ìƒíƒœ
            if (chart) {
                logCommand(`ì°¨íŠ¸ íƒ€ì…: ${chart.config.type}`);
                logCommand(`ë°ì´í„°ì…‹ ìˆ˜: ${chart.data.datasets ? chart.data.datasets.length : 0}`);
                logCommand(`ë¼ë²¨ ìˆ˜: ${chart.data.labels ? chart.data.labels.length : 0}`);
                
                if (chart.data.datasets && chart.data.datasets[0]) {
                    logCommand(`ë°ì´í„° í¬ì¸íŠ¸ ìˆ˜: ${chart.data.datasets[0].data ? chart.data.datasets[0].data.length : 0}`);
                }
            }
            
            // ì „ì—­ ë°ì´í„°
            logCommand(`ì „ì—­ ì£¼íŒŒìˆ˜ ë°°ì—´: ${frequencies ? frequencies.length + ' í•­ëª©' : 'undefined'}`);
            logCommand(`ì „ì—­ ìŠ¤í™íŠ¸ëŸ¼ ë°°ì—´: ${spectrumData ? spectrumData.length + ' í•­ëª©' : 'undefined'}`);
            
            updateDebugInfo(`ì°¨íŠ¸ ê°ì²´: ${chart ? 'ì¡´ì¬' : 'ì—†ìŒ'}, ìº”ë²„ìŠ¤: ${canvas ? 'ì¡´ì¬' : 'ì—†ìŒ'}`);
            
            logCommand('ğŸ” === ì°¨íŠ¸ ë””ë²„ê·¸ ì™„ë£Œ ===');
        }

        // Step 2: ê°•í™”ëœ ì°¨íŠ¸ ì´ˆê¸°í™”
        function initChart() {
            return new Promise((resolve, reject) => {
                try {
                    logCommand('ğŸ“ˆ Step 2: ì°¨íŠ¸ ì´ˆê¸°í™” ì‹œì‘...');
                    updateDebugInfo('ì°¨íŠ¸ ì´ˆê¸°í™” ì¤‘...');
                    
                    // Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¸
                    if (typeof Chart === 'undefined') {
                        throw new Error('Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•ŠìŒ');
                    }
                    
                    // ìº”ë²„ìŠ¤ ìš”ì†Œ í™•ì¸ ë° ëŒ€ê¸°
                    const canvas = document.getElementById('spectrumChart');
                    if (!canvas) {
                        throw new Error('ìŠ¤í™íŠ¸ëŸ¼ ì°¨íŠ¸ ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                    }
                    
                    // ë¶€ëª¨ ì»¨í…Œì´ë„ˆ í¬ê¸° í™•ì¸
                    const container = canvas.parentElement;
                    if (container.clientWidth === 0 || container.clientHeight === 0) {
                        logCommand('âš ï¸ ì»¨í…Œì´ë„ˆ í¬ê¸°ê°€ 0ì…ë‹ˆë‹¤. 100ms í›„ ì¬ì‹œë„...');
                        setTimeout(() => {
                            initChart().then(resolve).catch(reject);
                        }, 100);
                        return;
                    }
                    
                    // ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        throw new Error('ìº”ë²„ìŠ¤ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŒ');
                    }
                    
                    // ê¸°ì¡´ ì°¨íŠ¸ ì œê±°
                    if (chart) {
                        logCommand('ê¸°ì¡´ ì°¨íŠ¸ ì œê±° ì¤‘...');
                        chart.destroy();
                        chart = null;
                    }
                    
                    // ìƒˆ ì°¨íŠ¸ ìƒì„±
                    logCommand('ìƒˆ ì°¨íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì¤‘...');
                    chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'ì‹ í˜¸ ê°•ë„ (dBm)',
                                data: [],
                                borderColor: '#2563eb',
                                backgroundColor: 'rgba(37, 99, 235, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.1,
                                pointRadius: 0,
                                pointHoverRadius: 6,
                                pointBackgroundColor: '#2563eb',
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        font: {
                                            family: 'Inter',
                                            weight: '500',
                                            size: 14
                                        },
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                },
                                tooltip: {
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    cornerRadius: 8,
                                    displayColors: false,
                                    callbacks: {
                                        title: function(context) {
                                            return `ì£¼íŒŒìˆ˜: ${context[0].label} MHz`;
                                        },
                                        label: function(context) {
                                            return `ì‹ í˜¸ ê°•ë„: ${context.parsed.y.toFixed(1)} dBm`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'ì£¼íŒŒìˆ˜ (MHz)',
                                        font: {
                                            family: 'Inter',
                                            size: 14,
                                            weight: '600'
                                        },
                                        color: '#374151'
                                    },
                                    grid: {
                                        color: 'rgba(0, 0, 0, 0.1)',
                                        lineWidth: 1
                                    },
                                    ticks: {
                                        font: {
                                            family: 'Inter',
                                            size: 12
                                        },
                                        color: '#6b7280',
                                        maxTicksLimit: 10
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'ì‹ í˜¸ ê°•ë„ (dBm)',
                                        font: {
                                            family: 'Inter',
                                            size: 14,
                                            weight: '600'
                                        },
                                        color: '#374151'
                                    },
                                    grid: {
                                        color: 'rgba(0, 0, 0, 0.1)',
                                        lineWidth: 1
                                    },
                                    ticks: {
                                        font: {
                                            family: 'Inter',
                                            size: 12
                                        },
                                        color: '#6b7280'
                                    },
                                    min: -100,
                                    max: 10
                                }
                            },
                            onClick: (event, elements) => {
                                if (elements.length > 0) {
                                    const elementIndex = elements[0].index;
                                    if (frequencies && frequencies[elementIndex] !== undefined && 
                                        spectrumData && spectrumData[elementIndex] !== undefined) {
                                        const frequency = frequencies[elementIndex];
                                        const amplitude = spectrumData[elementIndex];
                                        updateMarker(frequency, amplitude);
                                    }
                                }
                            },
                            animation: {
                                duration: 750,
                                easing: 'easeInOutQuart'
                            }
                        }
                    });
                    
                    logCommand('âœ… Step 2 ì™„ë£Œ: ì°¨íŠ¸ ì´ˆê¸°í™” ì„±ê³µ');
                    updateDebugInfo('ì°¨íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');
                    
                    resolve(true);
                    
                } catch (error) {
                    logCommand(`âŒ Step 2 ì‹¤íŒ¨: ì°¨íŠ¸ ì´ˆê¸°í™” ì˜¤ë¥˜ - ${error.message}`);
                    updateDebugInfo(`ì°¨íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`);
                    console.error('ì°¨íŠ¸ ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                    reject(error);
                }
            });
        }

        // Step 3: ê°•í™”ëœ ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜
        async function testChart() {
            try {
                logCommand('ğŸ§ª Step 3: ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì‹œì‘...');
                updateDebugInfo('ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì¤‘...');
                
                if (!chart) {
                    logCommand('âŒ ì°¨íŠ¸ ê°ì²´ê°€ ì—†ìŒ. ì°¨íŠ¸ ì¬ì´ˆê¸°í™” ì‹œë„...');
                    await initChart();
                }
                
                // í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
                const testFreqs = [];
                const testData = [];
                
                // ë” í˜„ì‹¤ì ì¸ ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„° ìƒì„±
                for (let i = 0; i <= 50; i++) {
                    const freq = 1 + (i * 17.98); // 1MHz to 900MHz, 50 points
                    let amp = -90 + Math.random() * 15; // ê¸°ë³¸ ë…¸ì´ì¦ˆ í”Œë¡œì–´
                    
                    // ì—¬ëŸ¬ ì‹ í˜¸ ì¶”ê°€
                    if (Math.abs(freq - 100) < 5) {
                        amp = Math.max(amp, -25 - Math.abs(freq - 100) * 3);
                    }
                    if (Math.abs(freq - 433) < 10) {
                        amp = Math.max(amp, -35 - Math.abs(freq - 433) * 2);
                    }
                    if (Math.abs(freq - 868) < 8) {
                        amp = Math.max(amp, -30 - Math.abs(freq - 868) * 4);
                    }
                    if (Math.abs(freq - 50) < 3) {
                        amp = Math.max(amp, -40 - Math.abs(freq - 50) * 5);
                    }
                    
                    testFreqs.push(freq);
                    testData.push(amp);
                }
                
                logCommand(`í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±: ${testFreqs.length}ê°œ í¬ì¸íŠ¸`);
                logCommand(`ì£¼íŒŒìˆ˜ ë²”ìœ„: ${testFreqs[0].toFixed(1)} - ${testFreqs[testFreqs.length-1].toFixed(1)} MHz`);
                logCommand(`ì§„í­ ë²”ìœ„: ${Math.min(...testData).toFixed(1)} - ${Math.max(...testData).toFixed(1)} dBm`);
                
                // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸ (ë” ì•ˆì „í•œ ë°©ì‹)
                chart.data.labels = testFreqs.map(f => f.toFixed(1));
                chart.data.datasets[0].data = [...testData];
                
                // ê°•ì œ ì—…ë°ì´íŠ¸
                chart.update('active');
                
                // ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
                frequencies = [...testFreqs];
                spectrumData = [...testData];
                
                logCommand('âœ… Step 3 ì™„ë£Œ: ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì„±ê³µ');
                updateDebugInfo('ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì™„ë£Œ - ì‹¤ì œ ë°ì´í„° í‘œì‹œë¨');
                
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                document.getElementById('statusDisplay').textContent = 
                    `í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¡œë“œë¨ - ${testFreqs.length}ê°œ í¬ì¸íŠ¸ (${testFreqs[0].toFixed(1)}-${testFreqs[testFreqs.length-1].toFixed(1)} MHz)`;
                
                // ì°¨íŠ¸ê°€ ì‹¤ì œë¡œ ë Œë”ë§ ë˜ì—ˆëŠ”ì§€ í™•ì¸
                setTimeout(() => {
                    const canvas = document.getElementById('spectrumChart');
                    if (canvas) {
                        logCommand(`ì°¨íŠ¸ ë Œë”ë§ í™•ì¸: ìº”ë²„ìŠ¤ í¬ê¸° ${canvas.width}x${canvas.height}`);
                    }
                }, 100);
                
            } catch (error) {
                logCommand(`âŒ Step 3 ì‹¤íŒ¨: ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜ - ${error.message}`);
                updateDebugInfo(`ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`);
                console.error('ì°¨íŠ¸ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
            }
        }

        // Step 4: ëŒ€ê¸° í•¨ìˆ˜
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Step 5: ë¡œê·¸ ì¶œë ¥ í•¨ìˆ˜
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            if (!logElement) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (message.includes('âŒ') || message.includes('Error') || message.includes('ì‹¤íŒ¨')) {
                console.error('tinySA:', message);
            } else if (message.includes('âš ï¸') || message.includes('Warning') || message.includes('ê²½ê³ ')) {
                console.warn('tinySA:', message);
            } else if (message.includes('âœ…') || message.includes('Success') || message.includes('ì„±ê³µ')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            if (!statusElement) return;
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²°ë¨ âœ“';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = false;
                    if (diagnoseBtn) diagnoseBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²° ì•ˆë¨';
                    if (connectBtn) connectBtn.disabled = false;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²° ì¤‘...';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }

        // íƒ€ì„ì•„ì›ƒê³¼ í•¨ê»˜ ì‘ë‹µ ì½ê¸° (v18 ë°©ì‹)
        async function readResponseWithTimeout(timeoutMs = 5000) {
            return new Promise(async (resolve, reject) => {
                let response = '';
                
                const timeout = setTimeout(() => {
                    reject(new Error('ì‘ë‹µ íƒ€ì„ì•„ì›ƒ'));
                }, timeoutMs);
                
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.includes('ch>') || 
                            response.includes('Ch>') || 
                            response.includes('CH>') ||
                            response.endsWith('> ') ||
                            response.endsWith('>')) {
                            break;
                        }
                        
                        if (response.length > 10000) {
                            break;
                        }
                    }
                    
                    clearTimeout(timeout);
                    
                    const cleaned = response
                        .replace(/ch>/gi, '')
                        .replace(/>/g, '')
                        .replace(/\r/g, '')
                        .trim();
                        
                    resolve(cleaned);
                    
                } catch (error) {
                    clearTimeout(timeout);
                    reject(error);
                }
            });
        }

        // ëª…ë ¹ ì „ì†¡ (v18 ë°©ì‹)
        async function sendCommand(command) {
            if (!isConnected) {
                logCommand(`ì‹œë®¬ë ˆì´ì…˜: ${command}`);
                return 'OK';
            }

            try {
                logCommand(`ì „ì†¡ ì¤‘: ${command}`);
                
                const data = new TextEncoder().encode(command + '\r');
                await writer.write(data);
                
                const response = await readResponseWithTimeout(5000);
                logCommand(`ì‘ë‹µ: "${response}"`);
                
                return response;
                
            } catch (error) {
                logCommand(`ëª…ë ¹ ì˜¤ë¥˜: ${error.message}`);
                throw error;
            }
        }

        // ë¹ ë¥¸ íƒ€ì„ì•„ì›ƒ ì½ê¸°
        async function readWithQuickTimeout(timeoutMs) {
            return new Promise(async (resolve) => {
                let response = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(response);
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 500))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.length > 10 || response.includes('>')) {
                            break;
                        }
                    }
                } catch (error) {
                    // ì½ê¸° ì˜¤ë¥˜ ë¬´ì‹œ
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                    resolve(response);
                }
            });
        }

        // ì—°ê²° ì •ë¦¬
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`ë¦¬ë” ì •ë¦¬ ì˜¤ë¥˜: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`ë¼ì´í„° ì •ë¦¬ ì˜¤ë¥˜: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`í¬íŠ¸ ë‹«ê¸° ì˜¤ë¥˜: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`ì •ë¦¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¥ì¹˜ ì—°ê²° (v18 ë°©ì‹)
        async function connectDevice() {
            const deviceMode = document.getElementById('deviceMode');
            
            // deviceModeê°€ ì—†ìœ¼ë©´ í•˜ë“œì›¨ì–´ ëª¨ë“œë¡œ ê°€ì •
            if (!deviceMode) {
                logCommand('âš ï¸ ì¥ì¹˜ ëª¨ë“œ ì„ íƒê¸°ê°€ ì—†ìŒ. í•˜ë“œì›¨ì–´ ëª¨ë“œë¡œ ì§„í–‰...');
            }

            if (!('serial' in navigator)) {
                alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Serial APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ê¸°ë°˜ ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
                return;
            }

            try {
                updateConnectionStatus('connecting', '1ë‹¨ê³„: í¬íŠ¸ ì„ íƒ ì¤‘...');
                
                logCommand('ğŸ” ì‹œë¦¬ì–¼ í¬íŠ¸ ìš”ì²­ ì¤‘...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    if (portError.message.includes('blocklist') || portError.message.includes('blocked')) {
                        logCommand('âŒ í¬íŠ¸ ì„ íƒ ì‹¤íŒ¨: ë¸Œë¼ìš°ì €ê°€ ì¥ì¹˜ë¥¼ ì°¨ë‹¨í•¨');
                        logCommand('ğŸ” ê°ì§€ëœ ë¬¸ì œ: USB ì¥ì¹˜ê°€ ì‹œë¦¬ì–¼ í¬íŠ¸ë¡œ ì¸ì‹ë˜ì§€ ì•ŠìŒ');
                        updateConnectionStatus('disconnected', 'í¬íŠ¸ ì„ íƒ ì‹¤íŒ¨ - USB ì¥ì¹˜ ë¬¸ì œ');
                        return;
                    } else if (portError.message.includes('No port selected')) {
                        logCommand('âš ï¸ ì‚¬ìš©ìê°€ í¬íŠ¸ ì„ íƒì„ ì·¨ì†Œí•¨');
                        updateConnectionStatus('disconnected', 'í¬íŠ¸ ì„ íƒ ì·¨ì†Œë¨');
                        return;
                    } else {
                        logCommand(`âŒ í¬íŠ¸ ì„ íƒ ì˜¤ë¥˜: ${portError.message}`);
                        updateConnectionStatus('disconnected', `í¬íŠ¸ ì„ íƒ ì‹¤íŒ¨: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`âœ… í¬íŠ¸ ì„ íƒë¨: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                if (portInfo.usbVendorId === 0x0483 && portInfo.usbProductId === 0x5740) {
                    logCommand('ğŸ¯ tinySA ì¥ì¹˜ í™•ì¸ë¨! (VID=0x0483, PID=0x5740)');
                } else if (portInfo.usbVendorId === 0x0483) {
                    logCommand('âš ï¸ STM32 ê¸°ë°˜ ì¥ì¹˜ ê°ì§€ë¨ (tinySAì¼ ê°€ëŠ¥ì„± ë†’ìŒ)');
                } else {
                    logCommand('â“ ì•Œ ìˆ˜ ì—†ëŠ” ì¥ì¹˜. ê³„ì† ì§„í–‰...');
                }

                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = selectedBaudRate === 'auto' ? 9600 : parseInt(selectedBaudRate);

                updateConnectionStatus('connecting', `2ë‹¨ê³„: ${baudRate} bpsë¡œ ì—°ê²° ì¤‘...`);
                logCommand(`ğŸ”§ ë³´ë“œë ˆì´íŠ¸: ${baudRate} bps`);

                await cleanupConnection();
                
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                logCommand(`ğŸ“¡ í¬íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì—´ë¦¼ (${baudRate} bps)`);

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                logCommand(`   â€¢ ë¦¬ë”/ë¼ì´í„° ì„¤ì • ì™„ë£Œ`);

                await sleep(300);

                updateConnectionStatus('connecting', `3ë‹¨ê³„: í†µì‹  í…ŒìŠ¤íŠ¸ (${baudRate} bps)`);
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    logCommand(`âœ… ì—°ê²° ì„±ê³µ!`);
                    updateConnectionStatus('connected', `tinySA ì—°ê²°ë¨ (${baudRate} bps)`);
                    
                    await basicInitialize();
                    return;
                } else {
                    throw new Error('í†µì‹  í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨');
                }
                
            } catch (error) {
                updateConnectionStatus('disconnected', `ì—°ê²° ì‹¤íŒ¨: ${error.message}`);
                logCommand(`ğŸš¨ ìµœì¢… ì—°ê²° ì‹¤íŒ¨: ${error.message}`);
                await cleanupConnection();
            }
        }

        // ë¹ ë¥¸ ì—°ê²° í…ŒìŠ¤íŠ¸
        async function quickConnectionTest() {
            try {
                logCommand('ğŸ”„ í†µì‹  í…ŒìŠ¤íŠ¸ ì‹œì‘...');
                
                await sleep(100);
                
                logCommand('   ğŸ“¤ í…ŒìŠ¤íŠ¸ 1: CR ì „ì†¡');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response1 = await readWithQuickTimeout(1500);
                logCommand(`   ğŸ“¥ ì‘ë‹µ 1: "${response1}" (ê¸¸ì´: ${response1.length})`);
                
                logCommand('   ğŸ“¤ í…ŒìŠ¤íŠ¸ 2: CRLF ì „ì†¡');
                await writer.write(new TextEncoder().encode('\r\n'));
                
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`   ğŸ“¥ ì‘ë‹µ 2: "${response2}" (ê¸¸ì´: ${response2.length})`);
                
                const combinedResponse = response1 + response2;
                logCommand(`   ğŸ” ê²°í•© ë¶„ì„: "${combinedResponse}"`);
                
                if (combinedResponse.includes('ch>') || 
                    combinedResponse.includes('Ch>') || 
                    combinedResponse.includes('CH>')) {
                    logCommand('   âœ… tinySA í”„ë¡¬í”„íŠ¸ "ch>" í™•ì¸ë¨');
                    return true;
                } else if (combinedResponse.includes('>')) {
                    logCommand('   âœ… ì¼ë°˜ í”„ë¡¬í”„íŠ¸ ">" í™•ì¸ë¨ (tinySAì¼ ê°€ëŠ¥ì„± ë†’ìŒ)');
                    return true;
                } else if (combinedResponse.length > 0) {
                    logCommand('   âš ï¸ ì‘ë‹µ ìˆ˜ì‹ ë˜ì—ˆìœ¼ë‚˜ í”„ë¡¬í”„íŠ¸ í˜•ì‹ì´ ë‹¤ë¦„');
                    if (combinedResponse.length > 3) {
                        logCommand('   ğŸ”„ ì‘ë‹µì´ ì¶©ë¶„í•¨, ì—°ê²° ì‹œë„');
                        return true;
                    }
                    return false;
                } else {
                    logCommand('   âŒ ì‘ë‹µ ì—†ìŒ');
                    return false;
                }
                
            } catch (error) {
                logCommand(`âŒ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`);
                return false;
            }
        }

        // ê¸°ë³¸ ì´ˆê¸°í™”
        async function basicInitialize() {
            try {
                logCommand('ğŸ”§ ê¸°ë³¸ ì´ˆê¸°í™” ì‹œì‘...');
                
                await sleep(200);
                await sendCommandSafe('resume', 1000);
                await sleep(200);
                
                logCommand('âœ… ê¸°ë³¸ ì´ˆê¸°í™” ì™„ë£Œ');
                
            } catch (error) {
                logCommand(`âš ï¸ ì´ˆê¸°í™” ê²½ê³ : ${error.message} (ì •ìƒ ì‘ë™ ê°€ëŠ¥)`);
            }
        }

        // ì¥ì¹˜ ì—°ê²° í•´ì œ
        async function disconnectDevice() {
            try {
                logCommand('ğŸ”Œ ì—°ê²° í•´ì œ ì‹œì‘...');
                updateConnectionStatus('connecting', 'ì—°ê²° í•´ì œ ì¤‘...');
                
                await cleanupConnection();
                serialPort = null;
                
                updateConnectionStatus('disconnected', 'ì¥ì¹˜ ì—°ê²°ì´ ì„±ê³µì ìœ¼ë¡œ í•´ì œë¨');
                
            } catch (error) {
                logCommand(`ì—°ê²° í•´ì œ ì˜¤ë¥˜: ${error.message}`);
                updateConnectionStatus('disconnected', 'ì—°ê²° í•´ì œë¨ (ì˜¤ë¥˜ ë°œìƒ)');
            }
        }

        // ì—°ê²° ì§„ë‹¨
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('âŒ ì¥ì¹˜ê°€ ì—°ê²°ë˜ì§€ ì•ŠìŒ');
                alert('ë¨¼ì € ì¥ì¹˜ë¥¼ ì—°ê²°í•˜ì„¸ìš”.');
                return;
            }

            try {
                logCommand('ğŸ” === ì¢…í•© ì§„ë‹¨ ì‹œì‘ ===');
                
                // ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸
                logCommand('1ï¸âƒ£ ê¸°ë³¸ í†µì‹  í™•ì¸...');
                const basicTest = await sendCommandSafe('', 1000);
                logCommand(`   ê¸°ë³¸ ì‘ë‹µ: "${basicTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                logCommand('2ï¸âƒ£ í”„ë¡¬í”„íŠ¸ í™•ì¸...');
                const promptTest = await sendCommandSafe('\r', 1000);
                logCommand(`   í”„ë¡¬í”„íŠ¸: "${promptTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                logCommand('3ï¸âƒ£ ê¸°ë³¸ ëª…ë ¹ í…ŒìŠ¤íŠ¸...');
                const resumeTest = await sendCommandSafe('resume', 2000);
                logCommand(`   Resume ì‘ë‹µ: "${resumeTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                // í•˜ë“œì›¨ì–´ ë°ì´í„° ì§„ë‹¨ ì¶”ê°€
                await diagnoseHardwareData();
                
                logCommand('ğŸ” === ì¢…í•© ì§„ë‹¨ ì™„ë£Œ ===');
                
            } catch (error) {
                logCommand(`âŒ ì§„ë‹¨ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ë¹ ë¥¸ íƒ€ì„ì•„ì›ƒ ì½ê¸°
        async function readWithQuickTimeout(timeoutMs) {
            return new Promise(async (resolve) => {
                let response = '';
                let completed = false;
                
                const timeout = setTimeout(() => {
                    if (!completed) {
                        completed = true;
                        resolve(response);
                    }
                }, timeoutMs);
                
                try {
                    while (!completed) {
                        const readPromise = reader.read();
                        const { value, done } = await Promise.race([
                            readPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('read timeout')), 500))
                        ]);
                        
                        if (done || completed) break;
                        
                        const text = new TextDecoder().decode(value);
                        response += text;
                        
                        if (response.length > 10 || response.includes('>')) {
                            break;
                        }
                    }
                } catch (error) {
                    // ì½ê¸° ì˜¤ë¥˜ ë¬´ì‹œ
                }
                
                if (!completed) {
                    completed = true;
                    clearTimeout(timeout);
                    resolve(response);
                }
            });
        }

        // ì—°ê²° ì •ë¦¬
        async function cleanupConnection() {
            try {
                if (reader) {
                    try { 
                        await reader.cancel();
                        await reader.releaseLock(); 
                    } catch (e) { 
                        logCommand(`ë¦¬ë” ì •ë¦¬ ì˜¤ë¥˜: ${e.message}`);
                    }
                    reader = null;
                }
                
                if (writer) {
                    try { 
                        await writer.releaseLock(); 
                    } catch (e) { 
                        logCommand(`ë¼ì´í„° ì •ë¦¬ ì˜¤ë¥˜: ${e.message}`);
                    }
                    writer = null;
                }
                
                if (serialPort && serialPort.readable) {
                    try { 
                        await serialPort.close(); 
                    } catch (e) { 
                        logCommand(`í¬íŠ¸ ë‹«ê¸° ì˜¤ë¥˜: ${e.message}`);
                    }
                }
            } catch (error) {
                logCommand(`ì •ë¦¬ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ì¥ì¹˜ ì—°ê²°
        async function connectDevice() {
            if (!('serial' in navigator)) {
                alert('ì´ ë¸Œë¼ìš°ì €ëŠ” Web Serial APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ê¸°ë°˜ ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
                return;
            }

            try {
                updateConnectionStatus('connecting', '1ë‹¨ê³„: í¬íŠ¸ ì„ íƒ ì¤‘...');
                
                logCommand('ğŸ” ì‹œë¦¬ì–¼ í¬íŠ¸ ìš”ì²­ ì¤‘...');
                
                try {
                    serialPort = await navigator.serial.requestPort();
                } catch (portError) {
                    if (portError.message.includes('No port selected')) {
                        logCommand('âš ï¸ ì‚¬ìš©ìê°€ í¬íŠ¸ ì„ íƒì„ ì·¨ì†Œí•¨');
                        updateConnectionStatus('disconnected', 'í¬íŠ¸ ì„ íƒ ì·¨ì†Œë¨');
                        return;
                    } else {
                        logCommand(`âŒ í¬íŠ¸ ì„ íƒ ì˜¤ë¥˜: ${portError.message}`);
                        updateConnectionStatus('disconnected', `í¬íŠ¸ ì„ íƒ ì‹¤íŒ¨: ${portError.message}`);
                        return;
                    }
                }

                const portInfo = serialPort.getInfo();
                logCommand(`âœ… í¬íŠ¸ ì„ íƒë¨: VID=0x${portInfo.usbVendorId?.toString(16) || '????'}, PID=0x${portInfo.usbProductId?.toString(16) || '????'}`);

                const selectedBaudRate = document.getElementById('baudRate').value;
                const baudRate = parseInt(selectedBaudRate);

                updateConnectionStatus('connecting', `2ë‹¨ê³„: ${baudRate} bpsë¡œ ì—°ê²° ì¤‘...`);
                logCommand(`ğŸ”§ ë³´ë“œë ˆì´íŠ¸: ${baudRate} bps`);

                await cleanupConnection();
                
                await serialPort.open({ 
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none',
                    bufferSize: 255
                });

                logCommand(`ğŸ“¡ í¬íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì—´ë¦¼ (${baudRate} bps)`);

                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                logCommand(`   â€¢ ë¦¬ë”/ë¼ì´í„° ì„¤ì • ì™„ë£Œ`);

                await sleep(300);

                updateConnectionStatus('connecting', `3ë‹¨ê³„: í†µì‹  í…ŒìŠ¤íŠ¸ (${baudRate} bps)`);
                const testResult = await quickConnectionTest();
                
                if (testResult) {
                    logCommand(`âœ… ì—°ê²° ì„±ê³µ!`);
                    updateConnectionStatus('connected', `tinySA ì—°ê²°ë¨ (${baudRate} bps)`);
                    
                    await basicInitialize();
                    return;
                } else {
                    throw new Error('í†µì‹  í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨');
                }
                
            } catch (error) {
                updateConnectionStatus('disconnected', `ì—°ê²° ì‹¤íŒ¨: ${error.message}`);
                logCommand(`ğŸš¨ ìµœì¢… ì—°ê²° ì‹¤íŒ¨: ${error.message}`);
                await cleanupConnection();
            }
        }

        // ë¹ ë¥¸ ì—°ê²° í…ŒìŠ¤íŠ¸
        async function quickConnectionTest() {
            try {
                logCommand('ğŸ”„ í†µì‹  í…ŒìŠ¤íŠ¸ ì‹œì‘...');
                
                await sleep(100);
                
                logCommand('   ğŸ“¤ í…ŒìŠ¤íŠ¸ 1: CR ì „ì†¡');
                await writer.write(new TextEncoder().encode('\r'));
                
                const response1 = await readWithQuickTimeout(1500);
                logCommand(`   ğŸ“¥ ì‘ë‹µ 1: "${response1}" (ê¸¸ì´: ${response1.length})`);
                
                logCommand('   ğŸ“¤ í…ŒìŠ¤íŠ¸ 2: CRLF ì „ì†¡');
                await writer.write(new TextEncoder().encode('\r\n'));
                
                const response2 = await readWithQuickTimeout(1000);
                logCommand(`   ğŸ“¥ ì‘ë‹µ 2: "${response2}" (ê¸¸ì´: ${response2.length})`);
                
                const combinedResponse = response1 + response2;
                logCommand(`   ğŸ” ê²°í•© ë¶„ì„: "${combinedResponse}"`);
                
                if (combinedResponse.includes('ch>') || 
                    combinedResponse.includes('Ch>') || 
                    combinedResponse.includes('CH>')) {
                    logCommand('   âœ… tinySA í”„ë¡¬í”„íŠ¸ "ch>" í™•ì¸ë¨');
                    return true;
                } else if (combinedResponse.includes('>')) {
                    logCommand('   âœ… ì¼ë°˜ í”„ë¡¬í”„íŠ¸ ">" í™•ì¸ë¨ (tinySAì¼ ê°€ëŠ¥ì„± ë†’ìŒ)');
                    return true;
                } else if (combinedResponse.length > 0) {
                    logCommand('   âš ï¸ ì‘ë‹µ ìˆ˜ì‹ ë˜ì—ˆìœ¼ë‚˜ í”„ë¡¬í”„íŠ¸ í˜•ì‹ì´ ë‹¤ë¦„');
                    if (combinedResponse.length > 3) {
                        logCommand('   ğŸ”„ ì‘ë‹µì´ ì¶©ë¶„í•¨, ì—°ê²° ì‹œë„');
                        return true;
                    }
                    return false;
                } else {
                    logCommand('   âŒ ì‘ë‹µ ì—†ìŒ');
                    return false;
                }
                
            } catch (error) {
                logCommand(`âŒ ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${error.message}`);
                return false;
            }
        }

        // ê¸°ë³¸ ì´ˆê¸°í™”
        async function basicInitialize() {
            try {
                logCommand('ğŸ”§ ê¸°ë³¸ ì´ˆê¸°í™” ì‹œì‘...');
                
                await sleep(200);
                await sendCommandSafe('resume', 1000);
                await sleep(200);
                
                logCommand('âœ… ê¸°ë³¸ ì´ˆê¸°í™” ì™„ë£Œ');
                
            } catch (error) {
                logCommand(`âš ï¸ ì´ˆê¸°í™” ê²½ê³ : ${error.message} (ì •ìƒ ì‘ë™ ê°€ëŠ¥)`);
            }
        }

        // ì¥ì¹˜ ì—°ê²° í•´ì œ
        async function disconnectDevice() {
            try {
                logCommand('ğŸ”Œ ì—°ê²° í•´ì œ ì‹œì‘...');
                updateConnectionStatus('connecting', 'ì—°ê²° í•´ì œ ì¤‘...');
                
                await cleanupConnection();
                serialPort = null;
                
                updateConnectionStatus('disconnected', 'ì¥ì¹˜ ì—°ê²°ì´ ì„±ê³µì ìœ¼ë¡œ í•´ì œë¨');
                
            } catch (error) {
                logCommand(`ì—°ê²° í•´ì œ ì˜¤ë¥˜: ${error.message}`);
                updateConnectionStatus('disconnected', 'ì—°ê²° í•´ì œë¨ (ì˜¤ë¥˜ ë°œìƒ)');
            }
        }

        // ë¡œê·¸ ì§€ìš°ê¸°
        function clearLog() {
            const logElement = document.getElementById('commandLog');
            if (logElement) {
                logElement.textContent = '';
                logCommand('ğŸ“‹ ë¡œê·¸ ì§€ì›Œì§');
            }
        }

        // ë§ˆì»¤ ì—…ë°ì´íŠ¸
        function updateMarker(frequency, amplitude) {
            const markerElement = document.getElementById('markerInfo');
            if (markerElement) {
                markerElement.innerHTML = `
                    <strong>ì£¼íŒŒìˆ˜:</strong> ${frequency.toFixed(2)} MHz<br>
                    <strong>ì§„í­:</strong> ${amplitude.toFixed(1)} dBm
                `;
            }
        }

        // CSV ë‹¤ìš´ë¡œë“œ
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('ë¨¼ì € ìŠ¤ìº”ì„ ì‹¤í–‰í•˜ì„¸ìš”.');
                return;
            }

            let csvContent = "ì£¼íŒŒìˆ˜(MHz),ì‹ í˜¸ê°•ë„(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Step 4: ëŒ€ê¸° í•¨ìˆ˜
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Step 5: ë¡œê·¸ ì¶œë ¥ í•¨ìˆ˜
        function logCommand(message) {
            const logElement = document.getElementById('commandLog');
            if (!logElement) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            
            logElement.textContent += logMessage + '\n';
            logElement.scrollTop = logElement.scrollHeight;
            
            if (message.includes('âŒ') || message.includes('Error') || message.includes('ì‹¤íŒ¨')) {
                console.error('tinySA:', message);
            } else if (message.includes('âš ï¸') || message.includes('Warning') || message.includes('ê²½ê³ ')) {
                console.warn('tinySA:', message);
            } else if (message.includes('âœ…') || message.includes('Success') || message.includes('ì„±ê³µ')) {
                console.log('tinySA:', message);
            } else {
                console.info('tinySA:', message);
            }
        }

        // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const diagnoseBtn = document.getElementById('diagnoseBtn');
            
            if (!statusElement) return;
            
            statusElement.className = `status-indicator ${status}`;
            
            switch(status) {
                case 'connected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²°ë¨ âœ“';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = false;
                    if (diagnoseBtn) diagnoseBtn.disabled = false;
                    isConnected = true;
                    break;
                case 'disconnected':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²° ì•ˆë¨';
                    if (connectBtn) connectBtn.disabled = false;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    isConnected = false;
                    break;
                case 'connecting':
                    statusElement.innerHTML = '<i class="fas fa-circle"></i> ì—°ê²° ì¤‘...';
                    if (connectBtn) connectBtn.disabled = true;
                    if (disconnectBtn) disconnectBtn.disabled = true;
                    if (diagnoseBtn) diagnoseBtn.disabled = true;
                    break;
            }
            
            if (message) {
                logCommand(message);
            }
        }
        async function diagnoseConnection() {
            if (!isConnected) {
                logCommand('âŒ ì¥ì¹˜ê°€ ì—°ê²°ë˜ì§€ ì•ŠìŒ');
                alert('ë¨¼ì € ì¥ì¹˜ë¥¼ ì—°ê²°í•˜ì„¸ìš”.');
                return;
            }

            try {
                logCommand('ğŸ” === ì¢…í•© ì§„ë‹¨ ì‹œì‘ ===');
                
                // ê¸°ë³¸ ì—°ê²° í…ŒìŠ¤íŠ¸
                logCommand('1ï¸âƒ£ ê¸°ë³¸ í†µì‹  í™•ì¸...');
                const basicTest = await sendCommandSafe('', 1000);
                logCommand(`   ê¸°ë³¸ ì‘ë‹µ: "${basicTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                logCommand('2ï¸âƒ£ í”„ë¡¬í”„íŠ¸ í™•ì¸...');
                const promptTest = await sendCommandSafe('\r', 1000);
                logCommand(`   í”„ë¡¬í”„íŠ¸: "${promptTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                logCommand('3ï¸âƒ£ ê¸°ë³¸ ëª…ë ¹ í…ŒìŠ¤íŠ¸...');
                const resumeTest = await sendCommandSafe('resume', 2000);
                logCommand(`   Resume ì‘ë‹µ: "${resumeTest || 'ì‘ë‹µ ì—†ìŒ'}"`);

                // í•˜ë“œì›¨ì–´ ë°ì´í„° ì§„ë‹¨ ì¶”ê°€
                await diagnoseHardwareData();
                
                logCommand('ğŸ” === ì¢…í•© ì§„ë‹¨ ì™„ë£Œ ===');
                
            } catch (error) {
                logCommand(`âŒ ì§„ë‹¨ ì˜¤ë¥˜: ${error.message}`);
            }
        }

        // ë¡œê·¸ ì§€ìš°ê¸°
        function clearLog() {
            const logElement = document.getElementById('commandLog');
            if (logElement) {
                logElement.textContent = '';
                logCommand('ğŸ“‹ ë¡œê·¸ ì§€ì›Œì§');
            }
        }

        // ìŠ¤ìº” ì‹œì‘ (v18 ë°©ì‹ - ê°„ì†Œí™”)
        async function startScan() {
            if (isScanning) {
                logCommand('âŒ ìŠ¤ìº” ì‹œì‘ ë¶ˆê°€: ì´ë¯¸ ìŠ¤ìº” ì¤‘');
                return;
            }
            
            isScanning = true;
            document.getElementById('statusDisplay').textContent = 'ìŠ¤ìº” ì¤‘...';
            logCommand('ğŸ”„ ìŠ¤í™íŠ¸ëŸ¼ ìŠ¤ìº” ì‹œì‘...');
            
            try {
                let data = null;

                if (isConnected) {
                    logCommand('ğŸ”— í•˜ë“œì›¨ì–´ ëª¨ë“œ: ì‹¤ì œ tinySAì—ì„œ ë°ì´í„° ìˆ˜ì‹  ì¤‘...');
                    try {
                        data = await getHardwareSpectrum();
                        
                        if (data && data.frequencies && data.frequencies.length > 0) {
                            logCommand(`âœ… í•˜ë“œì›¨ì–´ ë°ì´í„° ìˆ˜ì‹  ì„±ê³µ: ${data.frequencies.length} í¬ì¸íŠ¸`);
                        } else {
                            logCommand('âš ï¸ í•˜ë“œì›¨ì–´ ë°ì´í„° ë¬´íš¨, ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ì „í™˜');
                            data = null;
                        }
                    } catch (hwError) {
                        logCommand(`âŒ í•˜ë“œì›¨ì–´ ìŠ¤ìº” ì‹¤íŒ¨: ${hwError.message}`);
                        data = null;
                    }
                }
                
                // í•˜ë“œì›¨ì–´ ì‹¤íŒ¨ ë˜ëŠ” ë¯¸ì—°ê²°ì‹œ ì‹œë®¬ë ˆì´ì…˜ ì‚¬ìš©
                if (!data) {
                    logCommand('ğŸ¯ ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ì‚¬ìš©...');
                    
                    // ìŠ¤ìº” ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    data = simulateSpectrum();
                    logCommand(`ğŸ“Š ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ${data.frequencies.length}ê°œ ë°ì´í„° í¬ì¸íŠ¸ ìƒì„±`);
                }
                
                // ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì „ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
                if (!data || !data.frequencies || !data.spectrum || 
                    data.frequencies.length === 0 || data.spectrum.length === 0) {
                    throw new Error('ì˜ëª»ëœ ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„° ìƒì„±ë¨');
                }
                
                // ì°¨íŠ¸ ì—…ë°ì´íŠ¸
                await updateChart(data);
                
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                const statusMsg = `ìŠ¤ìº” ì™„ë£Œ - ${data.frequencies.length}ê°œ í¬ì¸íŠ¸, ë²”ìœ„: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                document.getElementById('statusDisplay').textContent = statusMsg;
                
                logCommand('âœ… ìŠ¤ìº” ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œ');
                
            } catch (error) {
                const errorMsg = `ìŠ¤ìº” ì˜¤ë¥˜: ${error.message}`;
                document.getElementById('statusDisplay').textContent = errorMsg;
                logCommand(`âŒ ${errorMsg}`);
                
                // ìµœì†Œ ëŒ€ì²´ ë°ì´í„° ìƒì„± ì‹œë„
                try {
                    logCommand('ğŸ†˜ ëŒ€ì²´ ë°ì´í„° ìƒì„± ì‹œë„...');
                    const fallbackData = {
                        frequencies: [1, 50, 100, 200, 500, 900],
                        spectrum: [-90, -85, -60, -70, -80, -95]
                    };
                    
                    await updateChart(fallbackData);
                    logCommand('âœ… ëŒ€ì²´ ë°ì´í„° ë¡œë“œ ì„±ê³µ');
                } catch (fallbackError) {
                    logCommand(`âŒ ëŒ€ì²´ ë°ì´í„° ì‹¤íŒ¨: ${fallbackError.message}`);
                }
            } finally {
                isScanning = false;
                logCommand('ğŸ ìŠ¤ìº” í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ');
            }
        }

        // ìŠ¤í™íŠ¸ëŸ¼ ì‹œë®¬ë ˆì´ì…˜ (v18 ë°©ì‹ - ê°„ì†Œí™”)
        function simulateSpectrum() {
            try {
                logCommand('ğŸ¯ ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„° ìƒì„± ì¤‘...');
                
                // ìœ íš¨ì„± ê²€ì‚¬ì™€ í•¨ê»˜ ë§¤ê°œë³€ìˆ˜ ê°€ì ¸ì˜¤ê¸°
                const startFreq = parseFloat(document.getElementById('startFreq').value) || 1;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) || 900;
                const points = parseInt(document.getElementById('scanPoints').value) || 101;
                const noiseLevel = -80; // ê³ ì • ë…¸ì´ì¦ˆ ë ˆë²¨

                logCommand(`   ë§¤ê°œë³€ìˆ˜: ${startFreq}-${stopFreq} MHz, ${points} í¬ì¸íŠ¸, ë…¸ì´ì¦ˆ ${noiseLevel} dBm`);

                // ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
                if (startFreq >= stopFreq) {
                    throw new Error('ì‹œì‘ ì£¼íŒŒìˆ˜ê°€ ì¢…ë£Œ ì£¼íŒŒìˆ˜ë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤');
                }
                if (points < 2 || points > 10000) {
                    throw new Error('í¬ì¸íŠ¸ëŠ” 2ì™€ 10000 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤');
                }

                // ì£¼íŒŒìˆ˜ ë°°ì—´ ìƒì„±
                const step = (stopFreq - startFreq) / (points - 1);
                const freqs = [];
                const spectrum = [];

                logCommand(`   ${points}ê°œ ì£¼íŒŒìˆ˜ í¬ì¸íŠ¸ ìƒì„±`);

                // ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„° ìƒì„±
                for (let i = 0; i < points; i++) {
                    const freq = startFreq + i * step;
                    let amplitude = noiseLevel + (Math.random() - 0.5) * 10;

                    // ëª‡ ê°œì˜ í…ŒìŠ¤íŠ¸ ì‹ í˜¸ ì¶”ê°€
                    if (Math.abs(freq - 100) < 5) {
                        amplitude = Math.max(amplitude, -20 - Math.abs(freq - 100) * 4);
                    }
                    if (Math.abs(freq - 433) < 10) {
                        amplitude = Math.max(amplitude, -30 - Math.abs(freq - 433) * 2);
                    }
                    if (Math.abs(freq - 868) < 8) {
                        amplitude = Math.max(amplitude, -25 - Math.abs(freq - 868) * 3);
                    }

                    freqs.push(freq);
                    spectrum.push(amplitude);
                }

                logCommand(`   ${spectrum.length}ê°œ ì§„í­ í¬ì¸íŠ¸ ìƒì„±ë¨`);
                logCommand(`   ì§„í­ ë²”ìœ„: ${Math.min(...spectrum).toFixed(1)} ~ ${Math.max(...spectrum).toFixed(1)} dBm`);

                return { 
                    frequencies: freqs, 
                    spectrum: spectrum 
                };

            } catch (error) {
                logCommand(`âŒ ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜: ${error.message}`);
                logCommand('ğŸ†˜ ë¹„ìƒ ëŒ€ì²´ ë°ì´í„° ì‚¬ìš©...');
                
                // ë¹„ìƒ ëŒ€ì²´ ë°ì´í„°
                return {
                    frequencies: [1, 100, 200, 500, 900],
                    spectrum: [-90, -60, -70, -80, -95]
                };
            }
        }

        // Step 8: ê°•í™”ëœ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        async function updateChart(data) {
            try {
                logCommand('ğŸ“ˆ Step 8: ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹œì‘...');
                updateDebugInfo('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì¤‘...');
                
                if (!chart) {
                    logCommand('âš ï¸ ì°¨íŠ¸ ê°ì²´ê°€ ì—†ìŒ. ì¬ì´ˆê¸°í™”...');
                    await initChart();
                }
                
                if (!data || !data.frequencies || !data.spectrum) {
                    throw new Error('ì˜ëª»ëœ ë°ì´í„° í˜•ì‹');
                }
                
                if (data.frequencies.length !== data.spectrum.length) {
                    throw new Error('ì£¼íŒŒìˆ˜ì™€ ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„° ê¸¸ì´ê°€ ë‹¤ë¦„');
                }
                
                if (data.frequencies.length === 0) {
                    throw new Error('ë°ì´í„°ê°€ ë¹„ì–´ìˆìŒ');
                }
                
                logCommand(`   ë°ì´í„° ê²€ì¦ ì™„ë£Œ: ${data.frequencies.length} í¬ì¸íŠ¸`);
                logCommand(`   ì£¼íŒŒìˆ˜ ë²”ìœ„: ${data.frequencies[0].toFixed(2)} - ${data.frequencies[data.frequencies.length-1].toFixed(2)} MHz`);
                logCommand(`   ì§„í­ ë²”ìœ„: ${Math.min(...data.spectrum).toFixed(1)} - ${Math.max(...data.spectrum).toFixed(1)} dBm`);
                
                // ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ (ê¹Šì€ ë³µì‚¬)
                frequencies = [...data.frequencies];
                spectrumData = [...data.spectrum];
                
                // ì°¨íŠ¸ ìŠ¤ì¼€ì¼ ìë™ ì¡°ì •
                const minAmp = Math.min(...data.spectrum);
                const maxAmp = Math.max(...data.spectrum);
                const ampRange = maxAmp - minAmp;
                const padding = ampRange * 0.1; // 10% íŒ¨ë”©
                
                // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
                chart.data.labels = data.frequencies.map(f => f.toFixed(1));
                chart.data.datasets[0].data = [...data.spectrum];
                
                // Yì¶• ë²”ìœ„ ìë™ ì¡°ì •
                chart.options.scales.y.min = Math.max(-120, minAmp - padding);
                chart.options.scales.y.max = Math.min(20, maxAmp + padding);
                
                // ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤í–‰ (ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜)
                logCommand('   ì°¨íŠ¸ ë Œë”ë§ ì‹œì‘...');
                chart.update('active');
                
                // ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°
                await new Promise(resolve => {
                    // Chart.js ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì´ë²¤íŠ¸ ëŒ€ê¸°
                    const onAnimationComplete = () => {
                        chart.options.animation.onComplete = null;
                        resolve();
                    };
                    
                    chart.options.animation.onComplete = onAnimationComplete;
                    
                    // ì•ˆì „ì¥ì¹˜: ìµœëŒ€ 2ì´ˆ ëŒ€ê¸°
                    setTimeout(resolve, 2000);
                });
                
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                const statusMsg = `ìŠ¤ìº” ì™„ë£Œ - ${data.frequencies.length}ê°œ í¬ì¸íŠ¸, ë²”ìœ„: ${data.frequencies[0].toFixed(1)} - ${data.frequencies[data.frequencies.length-1].toFixed(1)} MHz`;
                document.getElementById('statusDisplay').textContent = statusMsg;
                
                updateDebugInfo('ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                logCommand('âœ… Step 8 ì™„ë£Œ: ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì„±ê³µ');
                
                // ì°¨íŠ¸ ë Œë”ë§ í™•ì¸
                const canvas = document.getElementById('spectrumChart');
                if (canvas) {
                    logCommand(`   ìµœì¢… í™•ì¸: ìº”ë²„ìŠ¤ í¬ê¸° ${canvas.width}x${canvas.height}, ë°ì´í„° ${chart.data.datasets[0].data.length}ê°œ`);
                }
                
            } catch (error) {
                logCommand(`âŒ Step 8 ì‹¤íŒ¨: ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜ - ${error.message}`);
                updateDebugInfo(`ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error.message}`);
                throw error;
            }
        }

        // ì•ˆì „í•œ ëª…ë ¹ ì „ì†¡ (v18 ë°©ì‹)
        async function sendCommandSafe(command, timeoutMs = 2000) {
            try {
                logCommand(`ğŸ“¤ ì•ˆì „ ëª…ë ¹: ${command}`);
                await writer.write(new TextEncoder().encode(command + '\r'));
                
                const response = await readWithQuickTimeout(timeoutMs);
                logCommand(`ğŸ“¥ ì•ˆì „ ì‘ë‹µ: "${response}"`);
                
                return response;
            } catch (error) {
                logCommand(`âš ï¸ ì•ˆì „ ëª…ë ¹ "${command}" ì˜¤ë¥˜: ${error.message} (ë¬´ì‹œë¨)`);
                return null;
            }
        }

        // í•˜ë“œì›¨ì–´ ìŠ¤í™íŠ¸ëŸ¼ ê°€ì ¸ì˜¤ê¸° (v18 ë°©ì‹ - ê°„ì†Œí™”)
        async function getHardwareSpectrum() {
            try {
                const startFreq = parseFloat(document.getElementById('startFreq').value) * 1e6;
                const stopFreq = parseFloat(document.getElementById('stopFreq').value) * 1e6;
                const points = parseInt(document.getElementById('scanPoints').value);

                logCommand('ğŸ“¡ === í•˜ë“œì›¨ì–´ ìŠ¤í™íŠ¸ëŸ¼ ì¸¡ì • ì‹œì‘ ===');
                logCommand(`ë²”ìœ„ ì„¤ì •: ${startFreq/1e6} - ${stopFreq/1e6} MHz, ${points} í¬ì¸íŠ¸`);

                await sendCommandSafe('pause');
                await sleep(200);

                await sendCommandSafe(`sweep start ${Math.floor(startFreq)}`);
                await sleep(100);
                await sendCommandSafe(`sweep stop ${Math.floor(stopFreq)}`);
                await sleep(100);

                await sendCommandSafe('resume');
                
                const scanTime = Math.max(1000, points * 5);
                logCommand(`   ìŠ¤ìº” ì™„ë£Œ ëŒ€ê¸° ì¤‘... (${scanTime}ms)`);
                await sleep(scanTime);

                const freqResponse = await sendCommandSafe('frequencies', 5000);
                const dataResponse = await sendCommandSafe('data 0', 5000);
                
                if (!freqResponse || !dataResponse) {
                    throw new Error('ìŠ¤í™íŠ¸ëŸ¼ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨');
                }

                // ë°ì´í„° íŒŒì‹±
                const freqLines = freqResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const dataLines = dataResponse.split(/[\r\n]+/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0 && !isNaN(parseFloat(line)))
                    .map(line => parseFloat(line));

                const minLength = Math.min(freqLines.length, dataLines.length);
                const freqs = freqLines.slice(0, minLength).map(freq => freq / 1e6);
                const spectrum = dataLines.slice(0, minLength);

                logCommand('ğŸ“¡ === í•˜ë“œì›¨ì–´ ìŠ¤í™íŠ¸ëŸ¼ ì¸¡ì • ì™„ë£Œ ===');
                
                return { frequencies: freqs, spectrum: spectrum };
                
            } catch (error) {
                logCommand(`âŒ í•˜ë“œì›¨ì–´ ìŠ¤ìº” ì˜¤ë¥˜: ${error.message}`);
                return simulateSpectrum();
            }
        }

        // ë§ˆì»¤ ì—…ë°ì´íŠ¸
        function updateMarker(frequency, amplitude) {
            const markerElement = document.getElementById('markerInfo');
            if (markerElement) {
                markerElement.innerHTML = `
                    <strong>ì£¼íŒŒìˆ˜:</strong> ${frequency.toFixed(2)} MHz<br>
                    <strong>ì§„í­:</strong> ${amplitude.toFixed(1)} dBm
                `;
            }
        }

        // CSV ë‹¤ìš´ë¡œë“œ
        function downloadCSV() {
            if (frequencies.length === 0 || spectrumData.length === 0) {
                alert('ë¨¼ì € ìŠ¤ìº”ì„ ì‹¤í–‰í•˜ì„¸ìš”.');
                return;
            }

            let csvContent = "ì£¼íŒŒìˆ˜(MHz),ì‹ í˜¸ê°•ë„(dBm)\n";
            for (let i = 0; i < frequencies.length; i++) {
                csvContent += `${frequencies[i].toFixed(3)},${spectrumData[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spectrum_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // í˜ì´ì§€ ë¡œë“œ ì´ˆê¸°í™” (ê°•í™”ëœ ë²„ì „)
        window.addEventListener('load', async function() {
            logCommand('ğŸš€ === Step 1: ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘ ===');
            
            try {
                // í…Œë§ˆ ì´ˆê¸°í™”
                initTheme();
                
                updateDebugInfo('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...');
                
                // Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ í™•ì¸
                if (typeof Chart === 'undefined') {
                    logCommand('âŒ Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ë¡œë“œë˜ì§€ ì•ŠìŒ');
                    updateDebugInfo('Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì‹¤íŒ¨');
                    return;
                }
                
                logCommand('âœ… Chart.js ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ í™•ì¸');
                
                // DOMì´ ì™„ì „íˆ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
                await new Promise(resolve => {
                    if (document.readyState === 'complete') {
                        resolve();
                    } else {
                        window.addEventListener('load', resolve);
                    }
                });
                
                // ì°¨íŠ¸ ì»¨í…Œì´ë„ˆê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ëŒ€ê¸°
                const chartContainer = document.querySelector('.chart-wrapper');
                if (chartContainer) {
                    // ì»¨í…Œì´ë„ˆ í¬ê¸°ê°€ ì„¤ì •ë  ë•Œê¹Œì§€ ì ì‹œ ëŒ€ê¸°
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // ì°¨íŠ¸ ì´ˆê¸°í™”
                logCommand('ğŸ”„ ì°¨íŠ¸ ì´ˆê¸°í™” ì‹œì‘...');
                await initChart();
                logCommand('âœ… Step 1 ì™„ë£Œ: ì°¨íŠ¸ ì´ˆê¸°í™” ì„±ê³µ');
                
                // Web Serial API í™•ì¸
                if (!('serial' in navigator)) {
                    logCommand('âŒ ê²½ê³ : ì´ ë¸Œë¼ìš°ì €ëŠ” Web Serial APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    logCommand('ğŸ”§ í•´ê²°ë°©ë²•: Chrome, Edge, Opera ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
                    updateDebugInfo('Web Serial API ì§€ì› ì•ˆë¨');
                } else {
                    logCommand('âœ… Web Serial API ì§€ì›ë¨');
                    
                    // ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                    navigator.serial.addEventListener('disconnect', (event) => {
                        if (event.target === serialPort) {
                            updateConnectionStatus('disconnected', 'ğŸ”Œ ì¥ì¹˜ ì—°ê²° í•´ì œë¨ (USB ì¼€ì´ë¸” í™•ì¸)');
                            serialPort = null;
                            reader = null;
                            writer = null;
                        }
                    });
                }
                
                // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ ì¶”ê°€
                document.querySelectorAll('.card').forEach((card, index) => {
                    card.style.animationDelay = `${index * 0.1}s`;
                });
                
                // ì°¨íŠ¸ í¬ê¸° ì¡°ì • ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                window.addEventListener('resize', () => {
                    if (chart) {
                        chart.resize();
                        logCommand('ğŸ“ ì°¨íŠ¸ í¬ê¸° ì¡°ì •ë¨');
                    }
                });
                
                // ì´ˆê¸° í…ŒìŠ¤íŠ¸ ì°¨íŠ¸ í‘œì‹œ
                setTimeout(async () => {
                    logCommand('ğŸ”„ ì´ˆê¸° í…ŒìŠ¤íŠ¸ ì°¨íŠ¸ í‘œì‹œ...');
                    await testChart();
                }, 300);
                
                logCommand('âœ… ì „ì²´ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ');
                updateDebugInfo('ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ - ì°¨íŠ¸ ì¤€ë¹„ë¨');
                
            } catch (error) {
                logCommand(`âŒ ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}`);
                updateDebugInfo(`ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`);
                console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                
                // ì´ˆê¸°í™” ì‹¤íŒ¨ì‹œ ëŒ€ì²´ ë°©ë²• ì‹œë„
                logCommand('ğŸ”„ ëŒ€ì²´ ì´ˆê¸°í™” ì‹œë„...');
                setTimeout(async () => {
                    try {
                        await initChart();
                        await testChart();
                        logCommand('âœ… ëŒ€ì²´ ì´ˆê¸°í™” ì„±ê³µ');
                    } catch (retryError) {
                        logCommand(`âŒ ëŒ€ì²´ ì´ˆê¸°í™”ë„ ì‹¤íŒ¨: ${retryError.message}`);
                    }
                }, 1000);
            }
    </script>
</body>
</html>
